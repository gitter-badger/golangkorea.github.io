<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Golang Korean Community</title>
    <link>https://golangkorea.github.io/post/</link>
    <description>Recent content in Posts on Golang Korean Community</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Aug 2016 15:10:07 +0830</lastBuildDate>
    <atom:link href="https://golangkorea.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go언어 시작하기</title>
      <link>https://golangkorea.github.io/post/go-start/getting-start/</link>
      <pubDate>Sun, 28 Aug 2016 15:10:07 +0830</pubDate>
      
      <guid>https://golangkorea.github.io/post/go-start/getting-start/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://digveloper.ppillip.com/wp-content/uploads/2013/04/appenginegophercolor.jpg&#34; alt=&#34;Go 로고&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;go-언어에-대해서&#34;&gt;Go 언어에 대해서&lt;/h2&gt;

&lt;p&gt;구글이 2009년에 만든 비교적 새로운 프로그래밍 언어다. 2009년이면 거의 7년 이상된 구닥다리 언어잖아? 라고 생각 할 수 있겠으나, Ruby(1996년) 나 python(1991년) 과 비교해보면 느낌이 다를 것이다. V8 자바스크립트 엔진 개발에 참여했던 &lt;strong&gt;Robert Griesemer&lt;/strong&gt;, UTF-8을 만든 &lt;strong&gt;Rob Pike&lt;/strong&gt;, 초창기 유닉스 운영체제를 설계했으며 B언어(C언어의 전신)를 개발한 &lt;strong&gt;Ken Thompson&lt;/strong&gt;등 쟁쟁한 개발자들이 만든 언어다. 구글이 개발 했다는 프리미엄과 함께 &lt;strong&gt;도커(Docker)&lt;/strong&gt;의 개발 언어라는게 알려지면서 유명세를 타게 됐다.&lt;/p&gt;

&lt;p&gt;Python이나 Java와 같은 범용 프로그래밍 언어이며, 시스템 프로그래밍과 네트워크 프로그램의 개발을 목표로 만들어진 언어다. 비교적 최근에 만들어진 언어답게 C++, Java, Python 언어들의 장점을 상당 부분 수용했다. 이렇게 보면 최신 프로그래밍 언어들의 트랜드를 따를 것 같지만 코드는 &lt;strong&gt;C 언어&lt;/strong&gt;와 매우 비슷한 느낌을 준다.&lt;/p&gt;

&lt;p&gt;C 언어 처럼 컴파일이 되며, 컴파일 시간에 타입을 체크하는 정적 타입 언어다. 그리고 C 언어처럼 단순하다. 약 25개 정도의 키워드만이 제공되는데, 실제 코드를 만들다 보면 10개 내외의 키워드 만으로 프로그래밍이 가능하다. 아래 go 언어가 제공하는 키워드들이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로그래밍 언어에 대한 경험이 있다면 chan, defer, fallthrough 등을 제외한 키워드들의 이름과 용도를 미루어 짐작할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;키워드가 적은 만큼 복잡한 준비작업 없이 쉽게 시작 할 수 있으며, 몇 개의 키워드로 반복 사용 함으로써 프로그래밍 숙련도를 빠르게 높일 수 있다는 것도 큰 장점이다.&lt;/p&gt;

&lt;p&gt;Go 언어는 &lt;strong&gt;동시성(concurrency)&lt;/strong&gt;를 잘 지원하는 것으로 유명하다. Go는 &lt;strong&gt;고루틴(goroutine)&lt;/strong&gt;라는 경량스레드(lightweight thread)를 제공하는데, 고루틴간 메시지를 주고 받을 수 있는 채널(channel)을 이용하면, 아주 쉽게(정말 쉽다) 동시성 프로그램을 개발 할 수 있다. 고루틴은 얼랑(Erlang)의 경량 쓰레드와 매우 유사한데, &lt;strong&gt;2k&lt;/strong&gt; 정도로 그 크기가 매우 작다. 많은 수의 고루틴을 시스템 부담을 최소화 하면서 만들 수 있다.&lt;/p&gt;

&lt;p&gt;Go 언어를 사용하다보면, 웹 애플리케이션을 만들기가 매우 편하다는 느낌을 받게 된다. 특히 &lt;strong&gt;MSA(Microservice Architecture)&lt;/strong&gt;와 &lt;strong&gt;REST(Representational State Transfer)&lt;/strong&gt; 모델의 애플리케이션을 쉽게 만들 수 있다. 루비나 파이선 같은 언어의 경우 다양한 &lt;strong&gt;웹 프레임워크&lt;/strong&gt;중에서 선택을 고민하게 마련인데, Go 언어는 기본으로 제공하는 &lt;strong&gt;net/http&lt;/strong&gt; 패키지로 충분하다. 물론 Go 언어도 다양한 마이크로 프레임워크와 풀 프레임워크를 제공하긴 하지만 이런 프레임워크를 쓰면, &amp;ldquo;왜 프레임워크를 쓰세요 ? 그냥 기본(net/http) 패키지 쓰세요&amp;rdquo;라는 말을 들을 정도로 강력하다.&lt;/p&gt;

&lt;p&gt;대규모의 분산 시스템을 유지해야 하는 구글의 요구를 위해서 웹 개발 관련 패키지가 강력해진 것 같다.&lt;/p&gt;

&lt;h2 id=&#34;go-시작하기&#34;&gt;Go 시작하기&lt;/h2&gt;

&lt;h3 id=&#34;go-설치&#34;&gt;Go 설치&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/dl/&#34;&gt;golang.org&lt;/a&gt;에서 운영체제별로 Go 언어를 다운로드 할 수 있다. 2016년 8월 현재 최신 버전은 1.7이다. 압축을 푼 다음 &lt;strong&gt;/usr/local&lt;/strong&gt; 디렉토리로 복사했다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# wget https://storage.googleapis.com/golang/go1.7.linux-amd64.tar.gz
# tar -xvzf go1.7.linux-amd64.tar.gz
# mv go /usr/local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go 실행을 위해서 환경 변수를 설정했다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# export PATH=$PATH:/usr/local/go/bin
# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go를 실행해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# go version
go version go1.7 linux/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 작업 디렉토리 &amp;ldquo;&amp;lsquo;workspace&amp;rdquo;&amp;lsquo;를 만들었다. Go언어에게 작업 디렉토리를 알려주기 위해서 환경변수 &lt;strong&gt;GOPATH&lt;/strong&gt;도 설정했다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mkdir $HOME/workspace
# export GOPATH:$HOME/workspace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이들 환경변수들은 .bashrc 등에 설정해서, 로그인 시간에 적용되도록 하자.&lt;/p&gt;

&lt;p&gt;이것으로 go 언어 개발 환경을 마쳤다. 이제 Hello World 프로그램을 만들면서 Go 프로그램의 기본적인 특징들을 살펴보자.&lt;/p&gt;

&lt;h3 id=&#34;패키지-관리-시스템&#34;&gt;패키지 관리 시스템&lt;/h3&gt;

&lt;p&gt;Hello World 프로그램을 만들기 전에 Go 언어의 패키지 관리 시스템을 살펴봐야 할 것같다. 앞서 나는 workspace 라는 작업 디렉토리를 만들었다. 다른 프로그램이라면 workspace 디렉토리 밑에 프로젝트 파일을 만드는 것으로 개발을 시작할 것이다. 예컨데 mkdir workspace/helloworld 로 디렉토리를 먼저 만들 것이다.&lt;/p&gt;

&lt;p&gt;go 언어는 다르다. 우선 go 언어는 &lt;strong&gt;인터넷&lt;/strong&gt;을 기본 개발 환경으로 한다. Go로 원할히 개발하기 위해서는 컴퓨터가 인터넷에 연결되어 있어야 하며, 코드를 저장하고 읽기 위한 github, bitbucket 혹은 직접 구성한 git 서버가 있어야 한다. 즉 go 언어에서 패키지는 프로젝트 저장소 단위로 관리한다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;strong&gt;sqlite3&lt;/strong&gt;을 사용하는 애플리케이션을 개발한다고 가정해 보자. 이를 위해서 sqlite3 패키지를 go get으로 다운로드 해야 하는데 git 주소로 부터 다운로드 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/mattn/go-sqlite3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;거의 모든 패키지가 이처럼 인터넷 상에 있는 git으로 관리 되고 있다. sqlite3 패키지를 설치한 후 workspace를 살펴보자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── pkg
│   └── linux_amd64
│       └── github.com
│           └── mattn
│               └── go-sqlite3.a
├── src 
|   └── github.com
|       └── mattn
|           └── go-sqlite3
|               ├── backup.go
|               ├── backup_test.go
|               ├── callback.go
|               ├── callback_test.go
└── bin 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;패키지의 경로가 github 경로인 것을 확인 할 수 있다. 물론 인터넷에 연결하지 않고도 프로젝트를 수행 할 수는 있지만 제대로 go 프로그래밍을 하려면 인터넷과 github 계정이 필요하다. 아래 주요 디렉토리의 용도를 정리했다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;src : 패키지의 소스코드가 위치한다.&lt;/li&gt;
&lt;li&gt;pkg : 패키지의 소스코드를 빌드해서 만들어진 라이브러리 파일(.a - ar archive 파일)이 위치한다. go-sqlite3.a 파일이 보일 것이다.&lt;/li&gt;
&lt;li&gt;bin : 패키지가 main 함수를 포함할 경우 실행 파일이 만들어 지는데, 이들 실행파일이 복사된다. go-sqlite3는 실행파일이 없으므로 bin에 파일이 복사되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래에서 다룰 Hello World 프로젝트도 github 기반으로 진행 할 것이다. github 계정이 없다면 지금 계정을 만들자. 내가 사용하고 있는 github 계정은 &lt;strong&gt;yundream&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;hello-world를-만들어보자&#34;&gt;Hello World를 만들어보자.&lt;/h3&gt;

&lt;p&gt;Hello World 프로젝트를 시작하기 위해서 내가 사용하는 github 계정에 helloworld 프로젝트를 만들었다. 프로젝트를 만들 때 &lt;strong&gt;Initialize this repository with a README&lt;/strong&gt; 옵션을 체크하자. 이제 go get 명령을 이용해서 패키지를 다운로드 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/yundream/helloworld
package github.com/yundream/helloworld: no buildable Go source files in /home/yundream/golang/src/github.com/yundream/helloworld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금은 README.md 파일만 있으므로 빌드 할 수 있는 go 파일이 없다는 경고메시지뜰 것이다. 무시하자. &lt;strong&gt;GOPATH&lt;/strong&gt; 환경에 등록된 /home/yundream/golang 디렉토리 밑에 패키지를 다운로드(README.md) 해서 설치하는 것을 확인 할 수 있을 것이다. 디렉토리로 이동해서 helloworld.go 파일을 만들어보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)

func main() {
    fmt.Println(&amp;quot;Hello World&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;터미널에 &amp;ldquo;Hello World&amp;rdquo;를 출력하는 간단한 프로그램이다. go run 명령으로 실행해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run main.go 
Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go run은 임시디렉토리에서 코드를 컴파일 하고 실행하는 일을 한다. go가 컴파일 언어임에도 불구하고 (컴파일 시간이 매우빠르다)유저 입장에서는 인터프리터 언어처럼 사용 할 수 있다. python 같은 언어에 비해서는 즉시성이 떨어지기는 하지만 왠만한 프로젝트에서는 굳이 컴파일 과정을 거치지 않고도 바로 바로 실행 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;go build&lt;/strong&gt; 명령으로 소스코드를 컴파일 할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go build
$ ls
README.md  helloworld  main.go
$ ./helloworld 
Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 소스코드를 살펴보자. C 언어와 매우 비슷하다는 느낌을 받을 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;패키지를 선언한다. 모든 go 언어는 패키지 선언으로 시작해야 한다. 이 패키지이름을 이용해서 코드를 조직화하고 재사용 할 수 있다. C언어와 유사하게 go 언어도 실행 프로그램과 라이브러리, 두 개의 코드 타입을 가지고 있다. 실행 프로그램이란 쉘 에서 명령을 내려서 직접 실행 할 수 있는 (우리가 일반적으로 알고 있는)프로그램이고, 라이브러리는 다른 프로그램에서 이용 할 수 있게 패키징된 코드의 모음이다. 실행 프로그램을 만들기 위한 go 코드는 반드시 &lt;strong&gt;package main&lt;/strong&gt;을 선언해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  &amp;quot;fmt&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;외부 패키지를 import 하기 위해서 사용한다. java의 import와 매우 유사하다. 위에서 go 코드는 실행 프로그램과 라이브러리 타입이 있다고 했던 것을 기억할 것이다. import는 라이브러리 타입의 go 코드를 재사용 하기 위해서 사용한다. 여기에서는 화면과 파일 출력에 관련된 여러 유용한 기능을 담고 있는 &lt;strong&gt;fmt&lt;/strong&gt; 패키지를 import했다. fmt는 git 저장소 경로가 없는데, go에서 제공하는 기본 패키지라고 보면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    fmt.Println(&amp;quot;Hello World&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go 언어의 기본 구성요소는 함수이며, func 키워드로 정의해서 사용 할 수 있다. 이 함수의 이름은 main 이며, 0개의 매개변수(parameter)과 0개의 반환 값을 가지고 있다. main은 프로그램의 시작 점이 되는 특수한 함수다. 실행 가능한 타입의 go 코드는 반드시 하나의 main 함수를 가지고 있어야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(&amp;quot;Hello World&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;fmt&lt;/strong&gt;는 패키지 이름으로 해석하자면 fmt 패키지가 가지고 있는 &lt;strong&gt;Println&lt;/strong&gt; 함수를 사용해서 &amp;ldquo;Hello World&amp;rdquo;를 출력하라는 의미가 된다.&lt;/p&gt;

&lt;p&gt;빌드 성공까지 끝냈다면 main.go를 github 저장소에 push하자. 그리고 go get 으로 다시 패키지를 다운로드 해보자. go get으로 패키지를 설치 하면 소스코드들은 $GOPATH/src 밑에 설치된다. 만약 패키지가 실행 가능한 코드 즉 main 함수를 포함하고 있다면 빌드를 수행하고 그 결과를 $GOPATH:/bin 에 복사한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# $GOPATH/bin/helloworld
Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go 프로젝트를 진행하다 보면, go get을 이용해서 go 기반의 소프트웨어들을 설치하게 될 것이다. 이들은 $GOPATH/bin에 설치가 되니, 실행을 위해서 환경변수 PATH에 &lt;strong&gt;$GOPATH/bin&lt;/strong&gt; 도 추가하자.&lt;/p&gt;

&lt;p&gt;만약 패키지를 지우고 싶다면 $GOPATH/src로 이동해서 패키지 디렉토리를(이 경우 $GOPATH/src/github.com/yundream/helloworld) 지워주기만 하면 된다.&lt;/p&gt;

&lt;h3 id=&#34;첫-번째-패키지-개발&#34;&gt;첫 번째 패키지 개발&lt;/h3&gt;

&lt;p&gt;이제 라이브러리 타입의 패키지를 만들어 보자. 패키지의 이름은 &lt;strong&gt;stringutil&lt;/strong&gt;로 문자열 조작과 관련된 함수들을 만들 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package stringutil

func Reverse(s string) string {
	r := []rune(s)
	for i, j := 0, len(r)-1; i &amp;lt; len(r)/2; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
	return string(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reverse 함수 하나만을 포함하고 있다. 매개변수로 받은 문자를 뒤집어서 반환하는 일을 한다.&lt;/p&gt;

&lt;p&gt;github 계정에 stringutil 저장소를 만들고 stringutil.go 파일을 push 한후, go get 으로 패키지를 다운로드하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go get github.com/yundream/stringutil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go get으로 설치된 패키지를 확인해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# go list ... | grep yundream
github.com/yundream/helloworld
github.com/yundream/stringutil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stringutil는 라이브러리 타입의 패키지로 빌드한 결과는 pkg/ 디렉토리 밑에 .a 파일로 저장된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# file $GOPATH/pkg/linux_amd64/github.com/yundream/stringutil.a
/home/yundream/golang/pkg/linux_amd64/github.com/yundream/stringutil.a: current ar archive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 helloworld 패키지에서 stringutil 패키지를 임포트해서 함수를 사용 할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;github.com/yundream/stringutil&amp;quot;
)

func main() {
    fmt.Println(&amp;quot;Hello World !!&amp;quot;)
    val := stringutil.Reverse(&amp;quot;ABCDEF&amp;quot;)
    fmt.Println(val)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행해 보면 stringutil.Reverse 함수가 작동하는 걸 확인할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go run main.go 
Hello World !!
FEDCBA
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;one-파일-배포&#34;&gt;One 파일 배포&lt;/h3&gt;

&lt;p&gt;Go 언어에서 라이브러리 타입의 패키지들은 &lt;strong&gt;.a(정적 라이브러리)&lt;/strong&gt; 형태로 만들어진다. &lt;strong&gt;공유 라이브러리(Shared Library - 리눅스는 .so파일 윈도우즈는 dll)&lt;/strong&gt;를 지원하기는 하지만 운영체제에 따라 제한 적일 수 있다. 보통은 정적 라이브러리를 코드내에 포함해서 &lt;strong&gt;하나의 실행 파일로 배포&lt;/strong&gt;하는 방법을 사용한다.&lt;/p&gt;

&lt;p&gt;이 방법은 패키징이 단순해지며, 운영체제의 동적 라이브러리와의 호환문제에서 자유롭기 때문에 배포가 쉬워진다는 장점이 있다. 대신 라이브러리 코드가 포함되므로 코드가 더 커지고, 취약점이 있는 라이브러리에 대한 체크와 업데이트가 쉽지 않다는 문제가 있다. 특정 라이브러리에서 어떤 취약점이 발견됐다면, 해당 라이브러리를 포함한 모든 애플리케이션을 재 빌드 해야 한다.&lt;/p&gt;

&lt;p&gt;현대적인 애플리케이션들이 공유 라이브러리를 선호한다는 점에서 시대에 역행한다는 생각을 가질 수 있을 것이다. 이러한 방식을 선택한 이유를 생각해봐야 한다. 구글은 프라이빗한 클라우드 환경에서 작동하는 시스템 애플리케이션의 개발을 위해서 go 언어를 사용하고 있다. 다양한 운영체제와 운영 환경등을 가지고 있는 클라우드 환경에 애플리케이션을 배포하기 위해서는 외부 의존성을 없애고 빠르게 배포하는게 더 나을 것 이다. 프라이빗한 네트워크에서 실행되며, 직접 서비스에 관여하는 일도 없을 테니 취약점에 대한 대응 문제도 그리 심각하지 않을 것이다.&lt;/p&gt;

&lt;p&gt;클라우드와 같은 분산된 환경에서는 go 언어의 방식이 더 나을 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;마치며&#34;&gt;마치며&lt;/h2&gt;

&lt;p&gt;테스트에 사용한 코드들은 아래 github에서 찾을 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yundream/helloworld&#34;&gt;https://github.com/yundream/helloworld&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yundream/stringutil&#34;&gt;https://github.com/yundream/stringutil&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go get github.com/yundream/helloworld
# go get github.com/yundream/stringutil
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #5 - 사이트에 블로그 올리는 방법</title>
      <link>https://golangkorea.github.io/post/hugo-intro/how-to-contribute-content/</link>
      <pubDate>Tue, 23 Aug 2016 23:25:55 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/how-to-contribute-content/</guid>
      <description>

&lt;h1 id=&#34;사이트에-블로그-올리는-방법&#34;&gt;사이트에 블로그 올리는 방법&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://golangkorea.github.io&#34;&gt;Golang Korean Community 사이트&lt;/a&gt;는 깃헙의 &lt;a href=&#34;https://github.com/golangkorea&#34;&gt;golangkorea&lt;/a&gt; Organization의 웹사이트로 &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt;를 이용해 제작되고 있습니다. 현존하는 Static Site Generator중 가장 빠른 Hugo를 엔진으로 사용하고 주로 Go언어에 관련된 포스트와 글로벌 기술 동향및 최신의 개발 기법등을 소개하는 포스트를 다루고 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;참여자격&#34;&gt;참여자격&lt;/h1&gt;

&lt;p&gt;깃헙에 계정이 있는 개발자라면 누구나 제작에 참여하실 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;fork-it&#34;&gt;Fork it!&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://golangkorea.github.io&#34;&gt;Golang Korean Community 사이트&lt;/a&gt;는 다음과 같이 두개의 Repo를 가지고 개발됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/golangkorea/golangkorea-hugo&#34;&gt;golangkorea-hugo&lt;/a&gt;&lt;/strong&gt; Hugo로 제작하는 golangkorea.github.io의 소스 프로젝트입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/golangkorea/golangkorea.github.io&#34;&gt;golangkorea.github.io&lt;/a&gt;&lt;/strong&gt; golangkorea-hugo의 submodule로 Hugo로 빌드된 웹사이트입니다. 직접 이 repo에서 작업하지는 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포스트를 하기 위해서 우선 githubkorea-hugo를 fork하신다음 본인의 repo를 clone하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/myaccount/golangkorea-hugo.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clone-hugo-octopress&#34;&gt;clone hugo-octopress&lt;/h1&gt;

&lt;p&gt;미래에는 어떻게 바뀔지 모르겠지만 현재 golangkorea.github.io는 &lt;a href=&#34;https://github.com/parsiya/Hugo-Octopress&#34;&gt;hugo-octopress&lt;/a&gt; 테마를 사용하고 있습니다. &lt;code&gt;themes&lt;/code&gt; 폴더에 clone하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd themes
$ git clone https://github.com/parsiya/Hugo-Octopress.git
$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;start-hugo&#34;&gt;Start Hugo&lt;/h1&gt;

&lt;p&gt;이제 로컬에서 사이트를 열어볼 차례입니다. 다음 명령을 사용해서 Hugo의 웹서버를 시작하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;를 브라우저에 열어서 사이트가 뜨는 걸 확인하십시요.&lt;/p&gt;

&lt;h1 id=&#34;첫번째-포스트&#34;&gt;첫번째 포스트&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;hugo new&lt;/code&gt;명령을 사용해서 포스트의 작성을 시작하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/my-frist-blog.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;golangkorea.github.io는 &lt;code&gt;authors&lt;/code&gt; taxonomy를 지원합니다. 포스트의 Front Matter에 다름과 같이 저자의 영어 이름을 입력해 주십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-08-28T23:01:25-04:00&amp;quot;
draft = true
title = &amp;quot;my first post&amp;quot;

authors = [&amp;quot;Your Name&amp;quot;]
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;golangkorea.github.io는 저자의 소개 페이지를 지원합니다. 다름과 같이 본인의 이름을 hyphenated, lower-cased된 형태로 만들어 주십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new author/your-name.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;pull-request하기&#34;&gt;Pull Request하기&lt;/h1&gt;

&lt;p&gt;포스트의 작성이 끝나면 다음 과정을 거쳐 Pull Request해 주십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add -A
...
$ git commit -m&amp;quot;My first post&amp;quot;
...
$ git push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pull Request에 대한 자세한 내용은 &lt;a href=&#34;https://help.github.com/articles/about-pull-requests/&#34;&gt;GitHub의 도움말&lt;/a&gt;을 참조 하세요.&lt;/p&gt;

&lt;h1 id=&#34;최신의-golankorea-hugo-repo와-싱크하기&#34;&gt;최신의 golankorea-hugo repo와 싱크하기&lt;/h1&gt;

&lt;p&gt;포스트를 한 지 좀 시간이 지나다 보면 그 사이에 사이트에 많은 변화가 있을 수 있습니다. 그때는 본인의 로컬 repo를 최신의 golangkorea-hugo와 싱크 시킬 필요가 생깁니다. 새로운 포스트를 시작하기 전에 우선 로컬의 repo에 golangkorea-hugo를 upstream remote repo로 만드시고 나머지 단계를 따라 싱크 시키십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Add the remote, call it &amp;quot;upstream&amp;quot;:

git remote add upstream https://github.com/golangkorea/golangkorea-hugo.git

# Fetch all the branches of that remote into remote-tracking branches,
# such as upstream/master:

git fetch upstream

# Make sure that you&#39;re on your master branch:

git checkout master

# Rewrite your master branch so that any commits of yours that
# aren&#39;t already in upstream/master are replayed on top of that
# other branch:

git rebase upstream/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merge를 하는 경우에는 &lt;code&gt;rebase&lt;/code&gt;를 &lt;code&gt;merge&lt;/code&gt;로 바꿔주시면 됩니다. &lt;a href=&#34;https://help.github.com/articles/syncing-a-fork/&#34;&gt;깃헙의 공식 도움말&lt;/a&gt;을 참조하십시요&lt;/p&gt;

&lt;p&gt;일단 싱크되면 본인의 forked repo에 다시 푸쉬하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push -f origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 새로운 포스트를 작성하십시요.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #4 - 분류(Taxonomy)기능 사용하기</title>
      <link>https://golangkorea.github.io/post/hugo-intro/taxonomy-basic/</link>
      <pubDate>Tue, 23 Aug 2016 23:25:44 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/taxonomy-basic/</guid>
      <description>

&lt;h1 id=&#34;분류-taxonomy-기능-사용하기&#34;&gt;분류(Taxonomy)기능 사용하기&lt;/h1&gt;

&lt;p&gt;사이트에 컨텐트가 많아 질 수록 고민이 생깁니다. 비숫한 주제의 컨텐트를 한 곳에 나열해 주는 페이지를 만들수는 없는가? 순진한 저자는 자기가 포스트한 내용을 모두 한 포스트에 링크할 지도 모릅니다. 주제 별로 나열해 주는 포스트를 만들어 새로운 포스트가 올라올 때 마다 링크를 걸어 줄 수도 있겠죠. 손이 많이 가고 더군다나 다른 저자들의 비슷한 포스트는 포함되지 못하는 일도 허다할 겁니다.&lt;/p&gt;

&lt;p&gt;Hugo는 이런 문제를 분류(taxonomy)라는 기능으로 간단히 햬결해 드립니다.&lt;a href=&#34;#footnote-1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 기본적으로 Hugo에는 &lt;code&gt;tags&lt;/code&gt;와 &lt;code&gt;categories&lt;/code&gt;라는 분류변수를 지원합니다. 컨텐트 저자가 할 일은 단지 Front Matter에 명시해 주기만 하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-08-23T23:25:44-04:00&amp;quot;
draft = false
title = &amp;quot;시리즈 #4 - 분류(Taxonomy)기능 사용하기&amp;quot;

tags = [&amp;quot;Blog&amp;quot;, &amp;quot;Hugo&amp;quot;]
categories = [&amp;quot;How-to&amp;quot;]
series = [&amp;quot;Hugo Introduction&amp;quot;]
authors = [&amp;quot;Jhonghee Park&amp;quot;]

toc = true
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 &lt;code&gt;How-to&lt;/code&gt; category의 경우 Hugo는 모든 컨텐트를 스캔하면서 해당 컨텐트들을 &lt;code&gt;/categories/how-to/index.html&lt;/code&gt;로 나열해 줍니다. 다시 말하면 taxonomy기능이 컨텐트내에 사용되면 taxonomy에 지정된 template을 이용해 Hugo는 모든 taxonomy페이지를 자동으로 만들고 사용된 term과 각 term을 사용한 컨텐트를 나열합니다.&lt;/p&gt;

&lt;h1 id=&#34;taxonomy-용어-정리&#34;&gt;Taxonomy 용어 정리&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Taxonomy&lt;/strong&gt; 같은 카테고리의 컨텐트를 분류하는 방식 (예: tag, category, author 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Term&lt;/strong&gt; taxonomy에 속하는 키워드 (author의 예를 들면 &lt;code&gt;Jhonghee Park&lt;/code&gt;, &lt;code&gt;Sangbae Yun&lt;/code&gt;, &lt;code&gt;Kookheon Kwon&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value&lt;/strong&gt; term이 사용된 컨텐트의 내용&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;taxonomy-organization&#34;&gt;Taxonomy Organization&lt;/h1&gt;

&lt;p&gt;Taxonomy의 관점에서 본 Organization은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;author                                     &amp;lt;-- Taxonomy
    Jhonghee Park                          &amp;lt;-- Term
        ReadMe First                       &amp;lt;-- Content
        시리즈 #1 - Hugo 시작하기           &amp;lt;-- Content
        시리즈 #2 - 컨텐츠 제작 기초         &amp;lt;-- Content
        ...
    Sangbae Yun                            &amp;lt;-- Term
        Go언어 시작하기                    &amp;lt;-- Content
        Golang 프로젝트에 TDD 도입하기      &amp;lt;-- Content
        vim-go를 이용한 go 개발 환경 구축   &amp;lt;-- Content
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컨텐트의 관점에서 본 Organization은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;시리즈 #1 - Hugo 시작하기      &amp;lt;-- Content
    author                    &amp;lt;-- Taxonomy
        Jhonghee Park         &amp;lt;-- Term
    series                    &amp;lt;-- Taxonomy
        Hugo 입문             &amp;lt;-- Term
Go언어 시작하기                &amp;lt;-- Content
    author                    &amp;lt;-- Taxonomy
        Sangbae Yun           &amp;lt;-- Term
    series                    &amp;lt;-- Taxonomy
        Go 시작하기            &amp;lt;-- Term
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;분류변수-taxonomies-의-정의&#34;&gt;분류변수(taxonomies)의 정의&lt;/h1&gt;

&lt;p&gt;분류변수는 사용하기 전에 사이트 configuration에 정의되어야 만 합니다. 단수형과 복수형을 사용해 다음과 같이 정의합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[taxonomies]
author = &amp;quot;authors&amp;quot;
category = &amp;quot;categories&amp;quot;
tag = &amp;quot;tags&amp;quot;
series = &amp;quot;series&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;컨텐트에-분류변수-지정하기&#34;&gt;컨텐트에 분류변수 지정하기&lt;/h1&gt;

&lt;p&gt;일단 분류변수가 사이트 레벨에 정의된 후에는 컨텐트 타입과 &lt;code&gt;section&lt;/code&gt;을 막론하고 어떤 컨텐트에도 사용 가능합니다. Front Matter에 복수형의 taxonomies를 써서 원하는 모든 Term을 나열하면 됩니다.&lt;/p&gt;

&lt;h1 id=&#34;taxonomy-템플릿&#34;&gt;Taxonomy 템플릿&lt;/h1&gt;

&lt;p&gt;Hugo는 일정한 규칙에 따라 Taxonomy 리스트 페이지를 만들어 냅니다. 주어진 Term의 모든 Taxonomy Value 리스트는 다음과 같은 URL 형식을 따릅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/{{복수형 Taxonomy 이름}}/{{Term}}/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이때 Term은 다음과 같은 변환을 거칩니다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;hyphenated&lt;/strong&gt; &lt;code&gt;How to&lt;/code&gt;는 &lt;code&gt;/categories/how-to&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lower-cased&lt;/strong&gt; &lt;code&gt;Jhonghee Park&lt;/code&gt;는 &lt;code&gt;/authors/jhonghee-park&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;normalized&lt;/strong&gt; &lt;code&gt;Gérard Depardieu&lt;/code&gt;는 &lt;code&gt;/actors/gerard-depardieu&lt;/code&gt;&lt;a href=&#34;#footnote-2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Taxonomy 페이지를 렌더링하기 위해서는 해당 Taxonomy의 템플릿이 필요합니다. 템프릿의 위치는 다음의 규칙을 따릅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/layouts/taxonomy/{{단수형 Taxonomy 이름}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Taxonomy, &lt;code&gt;authors&lt;/code&gt;의 경우, 템플릿은 &lt;code&gt;/layouts/taxonomy/author.html&lt;/code&gt;에 위치하게 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;hr/&gt;
&lt;br/&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a id=&#34;footnote-1&#34;&gt;&lt;/a&gt;Hugo v0.11이전에는 taxonomies를 indexes로 불렀습니다. 그런 이유로 만들어 진지 오래된 테마의 taxonomies 템플릿들은 &lt;code&gt;layouts/indexes&lt;/code&gt;에 위치 할 수도 있습니다.&lt;/li&gt;
  &lt;li&gt;Special Character를 보존하고자 하면 사이트 Configuraton에 &lt;code&gt;preserveTaxonomyNames = true&lt;/code&gt;를 지정해야 합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #3 - 사이트 테마 개발하기</title>
      <link>https://golangkorea.github.io/post/hugo-intro/theme-customizing/</link>
      <pubDate>Tue, 23 Aug 2016 23:25:30 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/theme-customizing/</guid>
      <description>

&lt;h1 id=&#34;사이트-테마-개발하기&#34;&gt;사이트 테마 개발하기&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/getting-started&#34;&gt;시리즈 1&lt;/a&gt; 마지막에 &lt;a href=&#34;http://themes.gohugo.io/hugo-octopress/&#34;&gt;hugo-octopress&lt;/a&gt; 테마를 사용하여 처음으로 사이트를 구축한 기억을 하실 겁니다. 사이트를 구축하기 전에 Hugo에서 사용할 수 있는 테마가 어떤것 있는지 한번 살펴보고 생각하고 있는 사이트와 잘 맞는 테마를 선택하는 일도 중요합니다. Hugo의 테마 쇼케이스에서 한번 감상하시길 바랍니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;Hugo 테마 쇼케이스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자신만의 테마를 개발하기 위한 첫걸음은 남이 개발해 놓은 테마를 사용하는 것에서 부터 시작합니다.&lt;/p&gt;

&lt;h1 id=&#34;테마-설치하는-법&#34;&gt;테마 설치하는 법&lt;/h1&gt;

&lt;p&gt;테마의 사용법은 대단히 간단합니다. &lt;code&gt;hugo new site&lt;/code&gt;명령으로 사이트 프로젝트를 초기화하면 &lt;code&gt;themes&lt;/code&gt; 폴더가 생기는 것을 이미 아실 것입니다. 사용하고자 하는 테마를 선택하고 난 뒤 &lt;code&gt;themes&lt;/code&gt; 폴더 밑에 다운로드 받은 테마 패키지를 설치해 주면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마의 깃헙주소를 아는 경우&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd themes
$ git clone https://github.com/parsiya/Hugo-Octopress.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;테마 쇼케이스의 모든 테마를 설치하는 경우&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes.git themes
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;테마-사용법&#34;&gt;테마 사용법&lt;/h1&gt;

&lt;p&gt;테마를 &lt;code&gt;themes&lt;/code&gt;에 설치하고 난 뒤 다음과 같이 선택한 테마로 사이트를 구축할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo -t ThemeName
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ThemeName은 &lt;code&gt;themes&lt;/code&gt; 폴더내 설치된 테마의 디렉토리 이름과 일치하여야 합니다.&lt;/p&gt;

&lt;h1 id=&#34;테마-커스터마이징&#34;&gt;테마 커스터마이징&lt;/h1&gt;

&lt;p&gt;설치된 테마를 사용하다 보면 맘에 들지 않는 부분이 생기거나 부족한 부분을 발견할 지도 모릅니다. &lt;strong&gt;&lt;em&gt;어떤 경우가 생기더라도 &lt;code&gt;themes&lt;/code&gt;밑에 설치된 테마에 속한 파일들을 직접 편집하지 마십시요&lt;/em&gt;&lt;/strong&gt;. Hugo는 이러한 경우가 생길때 보충하거나 기존의 템플릿을 오버라이드할 수 있도록 허락합니다. 설치된 테마의 구조를 살펴보시면 힌트를 얻을 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
└── Hugo-Octopress
    ├── LICENSE.md
    ├── README.md
    ├── images
    │   ├── Thumbs.db
    │   ├── codecaption1.png
    │   ├── screenshot.png
    │   └── tn.png
    ├── layouts
    │   ├── 404.html
    │   ├── _default
    │   │   ├── list.html
    │   │   ├── single.html
    │   │   └── terms.html
    │   ├── index.html
    │   ├── indexes
    │   │   ├── category.html
    │   │   └── tag.html
    │   ├── license
    │   │   └── single.html
    │   ├── partials
    │   │   ├── disqus.html
    │   │   ├── footer.html
    │   │   ├── header.html
    │   │   ├── navigation.html
    │   │   ├── octo-header.html
    │   │   ├── pagination.html
    │   │   ├── post_footer.html
    │   │   ├── post_header.html
    │   │   └── sidebar.html
    │   ├── post
    │   │   └── single.html
    │   └── shortcodes
    │       ├── codecaption.html
    │       └── imgcap.html
    ├── sample-config.toml
    ├── static
    │   ├── css
    │   │   └── hugo-octopress.css
    │   └── favicon.png
    └── theme.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금 개발하고 있는 사이트 프로젝트 폴더 밑으로 &lt;code&gt;layouts&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;archetypes&lt;/code&gt;가 있듯이 테마도 같은 구조를 가지고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;정적-리소스를-교체하는-법&#34;&gt;정적 리소스를 교체하는 법&lt;/h2&gt;

&lt;p&gt;테마에 따라온 jQuery버전이 맘에 안 드시나요? 교체하는 법은 기존의 것은 그대로 두고 새로운 jQuery버전을 다운로드 받아 테마에 위치한 장소와 같은 상대적 경로에 배치하면 Hugo는 테마의 jQuery를 사용하지 않고 프로젝트에 배치된 것을 사용해서 사이트를 구축합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마 밑&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/themes/themename/static/js/jquery.min.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;프로젝트 Root&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/static/js/jquery.min.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;템플릿-교체하는-법&#34;&gt;템플릿 교체하는 법&lt;/h2&gt;

&lt;p&gt;Hugo는 탬플릿을 찾을 때 항상 프로젝트 밑 &lt;code&gt;layouts&lt;/code&gt;폴더를 먼저 검색하고 없으면 테마의 &lt;code&gt;layouts&lt;/code&gt;을 찾아봅니다. 이런 Hugo의 특성을 이용하여 테마의 템프렛을 수정해야 할 필요가 생길 때 &lt;code&gt;layouts&lt;/code&gt;폴더 밑으로 같은 경로와 이름의 템플릿으로 교체하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마 밑&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/themes/themename/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;프로젝트 Root&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;특히 부분 템플릿(partial template)을 잘 활용한 테마의 경우 이런 교체법은 사이트의 보수유지를 최소화하고 미래에도 호환성을 보장하게 해 주는 장점을 가지고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;archetype-교체하는-법&#34;&gt;archetype 교체하는 법&lt;/h2&gt;

&lt;p&gt;Archetype을 제공하는 테마의 경우 &lt;code&gt;archetypes&lt;/code&gt;폴더로 교체하고자 하는 archetype 파일을 복사한 다음 필요에 맞게 수정하면 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;default-템플릿-사용-주의&#34;&gt;Default 템플릿 사용 주의&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;layouts/_default&lt;/code&gt;폴더내의 템플릿들은 테마에 비슷한 파일들을 가리지 않고 교체하는 효과가 있어 사용을 자제해야 합니다. 항상 default 템플릿을 사용하기 보다는 특정한 템플릿 교체가 더 낫다는 사실을 명심하십시요.&lt;/p&gt;

&lt;h1 id=&#34;새-테마-만들기&#34;&gt;새 테마 만들기&lt;/h1&gt;

&lt;p&gt;새로 테마를 만들기 위한 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new theme golangkorea
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &lt;code&gt;themes&lt;/code&gt;폴더 안에 다음과 같이 테마구조를 발생시킵니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;golangkorea
├── LICENSE.md
├── archetypes
│   └── default.md
├── layouts
│   ├── 404.html
│   ├── _default
│   │   ├── list.html
│   │   └── single.html
│   ├── index.html
│   └── partials
│       ├── footer.html
│       └── header.html
├── static
│   ├── css
│   └── js
└── theme.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;템플릿은 Go의 템플릿 언어로 만들어 집니다. &lt;a href=&#34;https://gohugo.io/layout/go-templates/&#34;&gt;Go template primer&lt;/a&gt;은 Go 템플릿 언어를 숙지하기 위한 좋은 출발점입니다.&lt;/p&gt;

&lt;h2 id=&#34;테마-콤퍼넌트&#34;&gt;테마 콤퍼넌트&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Layouts&lt;/strong&gt; 근본적으로 웹사이트는 두가지 형식의 페이지를 통해 컨텐트를 제공합니다: 컨텐트 자체가 하나의 페이지인 경우와 여러 항목을 나열해 놓은 페이지. Hugo의 테마는 이 두가지 페이지를 처리하는 기본(default) 템플릿에서 시작해서 컨텐트 타입(type)과 section을 통해 추가로 layout을 제공하는 템플릿을 준비합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single Content&lt;/strong&gt; 기본 템플릿은 &lt;code&gt;layouts/_default/single.html&lt;/code&gt;에 위치합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;List of Contents&lt;/strong&gt; 기본 템플릿은 &lt;code&gt;layouts/_default/list.html&lt;/code&gt;에 위치합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partial Templates&lt;/strong&gt; 부분 템플릿은 테마 제작에 있어 매우 중요한 요소입니다. 부분 템플릿을 통해 코드 재사용이 가능하고 아주 작은 부분만 교체하거나 삽입할 수 있게 해 주는 메카니즘이어서 테마의 유지보수가 간단해 지고 미래의 호환성을 보장해 줍니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Static&lt;/strong&gt; 테마내 정정 리소스의 구조는 전적으로 개발자에게 달려 있습니다. 보통은 &lt;code&gt;/css&lt;/code&gt;, &lt;code&gt;js&lt;/code&gt;, &lt;code&gt;img&lt;/code&gt;와 같은 폴더를 이용해 정적 자원을 관리합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Archetypes&lt;/strong&gt; 특정한 컨텐트 타입의 정면 변수를 정의하는 archetype을 테마에 포함시킬 수 있습니다. 자세한 내용은 &lt;a href=&#34;https://gohugo.io/content/archetypes/&#34;&gt;Archetype Guideline&lt;/a&gt;을 확인할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generator meta tag&lt;/strong&gt; 테마 개발자들에게 HTML의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;에 Generator meta tag, &lt;code&gt;.Hugo.Generator&lt;/code&gt;을 포함시킬 것을 권유합니다. Hugo의 사용과 인기도를 가늠하는데 도움을 줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #2 - 컨텐츠 제작 기초</title>
      <link>https://golangkorea.github.io/post/hugo-intro/content-basic/</link>
      <pubDate>Tue, 23 Aug 2016 23:25:04 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/content-basic/</guid>
      <description>

&lt;h1 id=&#34;컨텐츠-제작-기초&#34;&gt;컨텐츠 제작 기초&lt;/h1&gt;

&lt;p&gt;컨텐츠를 제작하면서 꼭 알아야 할 몇가지 개념을 정리하겠습니다.&lt;/p&gt;

&lt;h1 id=&#34;컨텐츠의-조직적인-관리-organization&#34;&gt;컨텐츠의 조직적인 관리 (Organization)&lt;/h1&gt;

&lt;p&gt;사이트가 많은 양의 컨텐츠를 보유하게 되면서 조직적인 관리가 필요할 때 Hugo가 어떻게 도와주는지 알아 봅시다. &lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/getting-started/&#34;&gt;시리즈 1&lt;/a&gt;에서 보았 듯이 Hugo의 &lt;code&gt;configuration&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;에 특별한 세팅이 없는 한 모든 컨텐츠는 &lt;code&gt;content&lt;/code&gt; 폴더 안에 위치하게 됩니다. Hugo를 통해 만들어질 사이트의 URL은 &lt;code&gt;content&lt;/code&gt;내의 폴더 구조와 매우 밀접한 관계가 있습니다. 우선 &lt;code&gt;content&lt;/code&gt; 바로 아래 위치하는 폴더는 &lt;code&gt;section&lt;/code&gt;이라고 부르는데 매우 중요한 역활을 합니다. 다음의 예는 &lt;code&gt;section&lt;/code&gt;이 사이트 URL과 어떤 상관이 있는지 암시합니다. 만들어진 사이트의 URL경로는 거울을 보듯이 컨텐츠 소스의 경로을 반영합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;.
|- content
   |- post
   |  |- firstpost.md   // &amp;lt;- http://1.com/post/firstpost/
   |  |- happy
   |  |  |- ness.md     // &amp;lt;- http://1.com/post/happy/ness/
   |  |- secondpost.md  // &amp;lt;- http://1.com/post/secondpost/
   |- quote
      |- first.md       // &amp;lt;- http://1.com/quote/first/
      |- second.md      // &amp;lt;- http://1.com/quote/second/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그렇다면 컨텐트가 소스의 경로와 다른 URL 경로를 가질 수는 없는 걸까요? 예를 들어,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;파일 이름 보다 좀 더 의미있는 단어가 URL에 나타나게 할 수는 없는가?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;section&lt;/code&gt;을 다른 이름으로 대체할 수는 없는가?&lt;/li&gt;
&lt;li&gt;다른 &lt;code&gt;section&lt;/code&gt;에 속한 컨텐트를 서로 조합해서 일관된 URL로 나타나게 할 수는 없는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 질문들에 대한 답을 얻기 위해서 다음의 개념들을 이해할 필요가 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;컨텐트-경로-destination&#34;&gt;컨텐트 경로 (Destination)&lt;/h1&gt;

&lt;p&gt;이미 살펴본 바와 같이 특별한 변수가 없다면 Hugo를 통해 생성된 컨텐트의 경로는 소스파일의 경로에 의해 결정됩니다. 하지만 컨텐트의 경로는 앞으로 살펴볼 정면 변수들(Front Matter)을 통해 다양한 형태로 조정될 수 있습니다. 그럼 Hugo는 컨텐트의 경로를 어떻게 조립하는 것일까요? 우선 몇가지 경로의 부분을 지칭하는 이름을 소개하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;            permalink
⊢--------------^-------------⊣
http://spf13.com/projects/hugo

    baseURL       section  slug
⊢-----^--------⊣ ⊢--^---⊣ ⊢-^⊣
http://spf13.com/projects/hugo

    baseURL       section          slug
⊢-----^--------⊣ ⊢--^--⊣        ⊢--^--⊣
http://spf13.com/extras/indexes/example

    baseURL            path       slug
⊢-----^--------⊣ ⊢------^-----⊣ ⊢--^--⊣
http://spf13.com/extras/indexes/example

    baseURL            url
⊢-----^--------⊣ ⊢-----^-----⊣
http://spf13.com/projects/hugo

    baseURL               url
⊢-----^--------⊣ ⊢--------^-----------⊣
http://spf13.com/extras/indexes/example
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;section&lt;/strong&gt; 컨텐트 타입의 기본값을 결정합니다.

&lt;ul&gt;
&lt;li&gt;컨텐트 소스의 위치에 따라 값이 정해집니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt; 정면변수의 값은 &lt;code&gt;section&lt;/code&gt; 부분경로를 바꿀 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slug&lt;/strong&gt; 확장자를 제외한 컨텐트 소스의 파일 이름으로 정해집니다.

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;slug&lt;/code&gt; 정면변수의 값을 통해 바꿀 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path&lt;/strong&gt; &lt;code&gt;section&lt;/code&gt;에서 시작하여 &lt;code&gt;slug&lt;/code&gt;직전까지의 경로

&lt;ul&gt;
&lt;li&gt;컨텐트 소스의 경로에 의해 결정됩니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;url&lt;/strong&gt; basicURL 다음부터 &lt;code&gt;slug&lt;/code&gt;까지 포함된 상대적인 URL

&lt;ul&gt;
&lt;li&gt;정면변수에 의해 결정될 수 있으며 컨텐트 경로를 결정하는 다른 정면변수의 영향을 무력화 합니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;slug&lt;/code&gt;나 &lt;code&gt;url&lt;/code&gt; 정면변수들을 통해 컨텐트의 목적지 경로(Destination)를 부분적으로 수정하거나 전면적으로 교체할 수 있다는 걸 알 수 있습니다. 이제 목적지 경로 변경 기능외에 컨텐트 처리와 HTML변환시 정면 변수들이 어떤 역활을 하는지 알아봅시다.&lt;/p&gt;

&lt;h1 id=&#34;정면-변수들-front-matter&#34;&gt;정면 변수들(Front Matter)&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Front Matter&lt;/code&gt;는 컨텐트의 메타 데이터라고 할 수 있습니다. 컨텐트보다 먼저 나타난다는 의미로 &lt;code&gt;front matter&lt;/code&gt;라는 이름을 지었을 것으로 추측해 봅니다. 시작과 끝을 나타내는 문자열에 따라 여러가지 포맷이 지원됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+++&lt;/code&gt;로 시작과 끝이 표시되면 &lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;TOML&lt;/a&gt;을 사용해 &lt;code&gt;Front Matter&lt;/code&gt;를 정의할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;---&lt;/code&gt;로 시작과 끝이 표시되면 &lt;a href=&#34;http://yaml.org&#34;&gt;YAML&lt;/a&gt;을 사용해 &lt;code&gt;Front Matter&lt;/code&gt;를 정의할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{&lt;/code&gt;로 시작하고 &lt;code&gt;}&lt;/code&gt;로 끝이 표시되면 &lt;a href=&#34;http://www.json.org&#34;&gt;JSON&lt;/a&gt;을 사용해 &lt;code&gt;Front Matter&lt;/code&gt;를 정의할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 글에서는 TOML의 예만을 살려보도록 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-08-23T23:25:04-04:00&amp;quot;
draft = true
title = &amp;quot;시리즈 #2 - 컨텐츠 제작 기초&amp;quot;
description = &amp;quot;Hugo 입문 두번째 시리즈로 컨텐츠 제작과 관련해 꼭 알아야 할 개념들을 소개합니다&amp;quot;

tags = [&amp;quot;Blog&amp;quot;, &amp;quot;Hugo&amp;quot;]
categories = [&amp;quot;How-to&amp;quot;]
series = [&amp;quot;Hugo Introduction&amp;quot;]
authors = [&amp;quot;Jhonghee Park&amp;quot;]

toc = true
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Front Matter&lt;/code&gt;로 정의될 수 있는 변수에 특별한 제약사항은 없습니다. 어떤 변수라도 템플렛안에서 &lt;code&gt;.Params.varname&lt;/code&gt;형식으로 접근할 수 있습니다. 템플릿 안에서 변수이름은 항상 소문자로 표현됩니다. 예를 들어 &lt;code&gt;camelCase = true&lt;/code&gt;라고 정의된 변수는 템플릿안에서는 &lt;code&gt;.Params.camelcase&lt;/code&gt;&lt;sup&gt;2&lt;/sup&gt;로 값을 출력할 수 있습니다. 다음은 컨텐트 제작에 필수적인 변수들입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt; 컨텐트의 제목&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;description&lt;/strong&gt; 컨텐트에 대한 설명&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;date&lt;/strong&gt; 컨텐츠를 정열할 때 사용할 날짜&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;taxonomies&lt;/strong&gt; 항상 복수형으로 표현되는 분류변수로 위의 예제에 나와있는 &lt;code&gt;tags&lt;/code&gt;, &lt;code&gt;categories&lt;/code&gt;, &lt;code&gt;series&lt;/code&gt;, 그리고 &lt;code&gt;authors&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외에 다음과 같은 선택적으로 사용할 수 있는 변수들도 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;aliases&lt;/strong&gt; 하나 이상의 이름들이 나열된 정렬(예를 들면 이름을 바꾼 컨텐트가 과거에 사용했던 URL)로 현재의 컨텐트 URL로 리디랙트 되는 별명들. 자세한 내용은 다음 링크를 참조, &lt;a href=&#34;https://gohugo.io/extras/aliases/&#34;&gt;Aliases&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;draft&lt;/strong&gt; 만약 값이 true이면, 컨텐트는 HTML로 만들어 지지 않습니다. 하지만 &amp;ndash;buildDrafts 플래크를 써서 강제할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;publishdate&lt;/strong&gt; 만약 날짜가 미래로 잡혀 있으면, 컨텐트는 HTML로 변환되지 않습니다. &amp;ndash;buildFuture 플래그를 써서 강제할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;type&lt;/strong&gt; 컨텐트 타입 (없는 경우는 컨텐트가 속한 디렉토리를 통해 값이 정해집니다. 즉, &lt;code&gt;type&lt;/code&gt;의 기본값은 &lt;code&gt;section&lt;/code&gt;을 통해 정해집니다.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isCJKLanguage&lt;/strong&gt; 값이 true인 경우, 컨텐트를 한중일 언어로 작성된 것으로 간주하고, &lt;code&gt;.Summary&lt;/code&gt;와 &lt;code&gt;WordCount&lt;/code&gt;와 같은 값들이 한중일 언어에 맞게 생성됩니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weight&lt;/strong&gt; 컨텐트의 차례를 정렬하는데 사용됩니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;markup&lt;/strong&gt; (실험적변수) &lt;code&gt;rst&lt;/code&gt;는 reStructuredText (rst2html 툴을 사용합니다) or &lt;code&gt;md&lt;/code&gt; (기본값) 은 Markdown&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slug&lt;/strong&gt; URL의 말단에 위치하는 토큰(token)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;url&lt;/strong&gt; 웹 루트에서 컨텐트까지의 전체 경로.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사이트 개발자의 입장에서 사이트의 기능을 확장하고 컨텐트 제작자에게 그 기능을 조종할 수 있는 인터페이스를 제공하려고 할 때 정면 변수를 유용하게 사용할 수 있습니다. 위에 정면변수 예를 보면, 렌더링된 컨텐트의 상단에 목차를 구현하고 그 기능을 컨텐트 제작시 &lt;code&gt;toc = true&lt;/code&gt;를 이용해 나타나게 하는 예가 있습니다. 또 다른 예는 &lt;code&gt;authors&lt;/code&gt;를 분류변수(taxonomies)로 등록하고 테마를 통해 구현한 뒤 정면변수의 하나로 컨텐트 제작자에게 자신의 이름을 입력할 수 있게 합니다. 컨텐츠 제작자는 항상 동일한 이름을 사용함으로서 사이트가 제공하는 컨텐츠 목록의 자동 발생을 사용할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;지원되는-컨텐트의-포맷&#34;&gt;지원되는 컨텐트의 포맷&lt;/h1&gt;

&lt;p&gt;컨텐트 상단에 정면변수들의 정의되고 그 뒤로 컨텐트의 내용이 따라옵니다. Hugo의 컨텐트는 다양한 포맷으로 제작될 수 있습니다. &lt;a href=&#34;http://www.methods.co.nz/asciidoc/&#34;&gt;asciidoc&lt;/a&gt;, &lt;a href=&#34;http://docutils.sourceforge.net/rst.html&#34;&gt;reStructuredText&lt;/a&gt;는 외부 프로그램의 도움을 얻어 지원되는 포맷들입니다. 외부 툴에 의존하지 않고 Hugo 자체적으로 컨텐트를 제작할 수 있는 포맷은 &lt;a href=&#34;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&#34;&gt;Markdown&lt;/a&gt;입니다. Markdown을 이용해 새로운 컨텐트를 제작하고 싶으면 &lt;code&gt;hugo new&lt;/code&gt;명령에 &lt;code&gt;md&lt;/code&gt;확장자를 가지는 파일이름을 사용해 시작할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/my-first-blog.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령이 실행되면 Markdown 파일이 만들어 지고 기본적인 정면변수들의 셑업이 이루어 집니다. 이 Scaffolding 과정에서 Hugo는 post라는 archetype을 찾기 위해 테마의 archetypes 폴더나 프로젝트 내 archetypes 폴더안을 검색하고 정면변수들의 기본 셑업을 진행합니다. 만약에 post archetype이 정의되어 있지 않을 때는 Hugo의 기본 값들을 사용합니다.&lt;/p&gt;

&lt;h1 id=&#34;컨텐트-타입과-전형-content-types-and-archetypes&#34;&gt;컨텐트 타입과 전형 (Content Types and archetypes)&lt;/h1&gt;

&lt;p&gt;컨텐트 타입은 기본적으로 소스의 위치가 어디에 있느냐에 따라 결정 됩니다. &lt;code&gt;post/my-first-blog.md&lt;/code&gt;에 작성된 컨텐트는 정면변수 &lt;code&gt;type&lt;/code&gt;이 존재하지 않는 한 post 컨텐트 타입으로 간주되어 타입에 맞는 렌더링이 이루어 집니다. 만약에 전혀 새로운 컨텐트 타입을 도입하고자 하면 어떻게 해야 할까요? 예를 들어 musician이라는 컨텐트 타입을 통해 유명한 음악가들의 소개를 하고자 하는 가정을 합시다. &lt;code&gt;hugo new musician/bach.md&lt;/code&gt;로 컨텐트를 초기화 했을때 Hugo의 입장에서는 musician이라는 컨텐트 타입으로 bach.md의 HTML을 렌더링하려고 할 것입니다. musician 컨텐트에 특화된 렌더링을 제공하려면 다음과 같이 새로운 탬플릿을 layouts에 추가해야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;우선 컨텐트 자체의 렌더링을 위해 &lt;code&gt;layouts/musician/single.html&lt;/code&gt;을 추가합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;section&lt;/code&gt; 리스트 페이지의 렌더링을 지원하기 위해서는 &lt;code&gt;layouts/section/musician.html&lt;/code&gt;을 추가합니다.&lt;/li&gt;
&lt;li&gt;음악가의 시대에 따라 조금씩 다른 페이지 뷰(View)를 제공하려면 &lt;code&gt;layouts/musician&lt;/code&gt;안에 변형된 템플릿을 추가하고 컨텐트의 정면변수로 &lt;code&gt;layout&lt;/code&gt;을 사용해 지정해 줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;템플릿을 준비하면서 musician 컨텐트 타입에 필요한 새로운 정면변수들이 생길 수 있습니다. 저자의 입장에서는 새로운 musician 컨텐트를 &lt;code&gt;hugo new&lt;/code&gt;명령으로 발생 시킨 후 첨가된 정면변수들을 일일이 &lt;strong&gt;기억&lt;/strong&gt;해서 입력해야 하는 불편함이 생깁니다. 이런 불편함을 해소하기 위해 musician 컨텐트 타입의 전형(archetype)을 정의해 줄 필요가 있습니다. musician archetype은 &lt;code&gt;archetypes/musician.md&lt;/code&gt;를 사용해 정의되고 이 archetype 문서에 필요한 기본값들을 지정해 줄 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;archetypes/musician.md&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
name = &amp;quot;&amp;quot;
bio = &amp;quot;&amp;quot;
genre = &amp;quot;&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 archetype을 사용해 새 musician 컨텐트를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new musician/mozart.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo는 musician 타입을 인지하고 준비된 archetype을 이용하여 정면변수들을 자동으로 입력해 줍니다.
&lt;strong&gt;content/musician/mozart.md&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
title = &amp;quot;mozart&amp;quot;
date = &amp;quot;2015-08-24T13:04:37+02:00&amp;quot;
name = &amp;quot;&amp;quot;
bio = &amp;quot;&amp;quot;
genre = &amp;quot;&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컨텐츠 저자의 관점에서 보면 이제 어느 정도 Hugo를 이용해 정적사이트를 건설할 준비가 끝난 셈입니다. 이어지는 시리즈에서는 사이트 개발자의 관점에서 어떻게 새로운 테마를 만들 수 있는지, 정면변수들과 사이트 구성변수(configuration)들이 템플릿안에서 어떻게 접근할 수 있는지를 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;br/&gt;
  &lt;ol&gt;
    &lt;li&gt;Hugo의 configuration은 특별한 조치가 없는 경우 프로젝트 폴더내 config.toml에 정의됩니다. TOML외 YAML과 JSON 포맷이 지원됩니다.&lt;/li&gt;
    &lt;li&gt;Hugo는 여러 템플릿 엔진을 지원합니다. 이 글에서는 Go언어의 자체적 &lt;code&gt;text/template&lt;/code&gt;을 사용하는 것을 전제합니다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #1 - Hugo 시작하기</title>
      <link>https://golangkorea.github.io/post/hugo-intro/getting-started/</link>
      <pubDate>Tue, 23 Aug 2016 23:24:55 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/getting-started/</guid>
      <description>

&lt;h1 id=&#34;hugo-시작하기&#34;&gt;Hugo 시작하기&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt;는 Go로 제작되고 하나의 실행파일로 배포됩니다. 다양한 설치 방법이 있지만 우선 Package Manager를 쓰시는 분들을 중심으로 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;package-manager로-설치하기&#34;&gt;Package Manager로 설치하기&lt;/h2&gt;

&lt;p&gt;MacOS를 쓰시는 분들은 Homebrew를 이용해 쉽게 설치하실 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update &amp;amp;&amp;amp; brew install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows에서 Chocolatey를 쓰시는 분들도 비슷한 방법으로 설치가 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; choco install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux에서는 조금 복잡해 집니다. 우분트를 쓰시는 분들은 우선 &lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;Hugo 릴리즈 페이지&lt;/a&gt;로 가서 최신 deb 버전을 다운로드한 후에 다음 명령을 실행 시키면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dpkg -i hugo*.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;소스로-직접-빌드해-쓰는-방법&#34;&gt;소스로 직접 빌드해 쓰는 방법&lt;/h2&gt;

&lt;p&gt;이미 Go로 개발 환경을 갖추고 계신 분들은 직접 소스를 빌드해 쓰시는 방법이 가장 편합니다. 간단히 &lt;code&gt;go get&lt;/code&gt;툴을 이용해 설치하실 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo가 설치되었는지를 &lt;code&gt;version&lt;/code&gt; 보조 명령어를 사용해 확인하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo version
Hugo Static Site Generator v0.17-DEV BuildDate: 2016-08-21T19:44:40-04:00
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;프로젝트-폴더-만들기&#34;&gt;프로젝트 폴더 만들기&lt;/h1&gt;

&lt;p&gt;정적 사이트 제너레이터를 처음 접하시는 분들을 위해 Hugo를 간단하게 설명하자면, Hugo는 소스 폴더 아래 존재하는 파일과 컨텐츠 템플릿을 입력으로 사용해서 웹사이트 전체를 출력하는 시스템입니다. 보통 소스는 &lt;a href=&#34;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&#34;&gt;Markdown&lt;/a&gt;을 이용한 컨텐츠이거나 템플릿 언어로 작성된 HTML에 자바스크립과 CSS스타일로 구성되어 웹 개발자에게 매우 친숙한 환경이라 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;  +------------------+
  |    Content       +--------+
  |    (Markdown)    |        |
  +------------------+        |           +------------+
  +------------------+     +--v---+       |Full Website|
  |Template          |     |      |       +-------+----+
  |(text/template)   |     | Hugo |       |       |    |
  |(Ace)             +-----&amp;gt;      +-------&amp;gt;       |    |
  |(Amber)           |     |      |       |       |    |
  +------------------+     +--^--^+       |       |    |
  +------------------+        |  |        |       |    |
  |Configuraton      |        |  |        +-------+----+
  |(toml, yaml, json)+--------+  |
  +------------------+           |
  +------------------+           |
  | Static           |           |
  | (image)          |           |
  | (javascript)     +-----------+
  | (css)            |
  +------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo는 커맨드라인 명령어 체계는 각종 보조 명령어와 POSIX를 준수하는 플래그로 구성되어 빌드와 유틸리티 기능을 제공합니다. 우선 Hugo가 제공하는 Scaffolding 명령어를 가지고 프로젝트 폴더를 만들어 보도록 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site golangkorea-hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo의 모든 명령&lt;a href=&#34;#footnote-1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;은 &lt;code&gt;hugo&lt;/code&gt;로 시작하고 보조 명령어가 뒤를 따릅니다. 여기서 &lt;code&gt;new&lt;/code&gt;는 보조 명령어로서 &lt;code&gt;site&lt;/code&gt; 보조 명령어와 함께 프로젝트를 초기화합니다. 초기화된 프로젝트의 폴더 구조는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd golangkorea-hugo
$ tree -a
.
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes

6 directories, 1 file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;초기화된 프로젝트에는 텅빈 폴더 6개와 &lt;code&gt;config.toml&lt;/code&gt; 파일 하나가 만들어 집니다. 각 폴더의 용도를 간단히 나열하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;archetypes: &lt;code&gt;hugo new&lt;/code&gt;명령으로 컨텐트 생성시 &lt;a href=&#34;https://gohugo.io/content/front-matter/&#34;&gt;Front Matter&lt;/a&gt;&lt;a href=&#34;#footnote-2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 에 컨텐트 타입에 따른 기본 값들을 어떻게 정해줄 것인가를 결정하는 파일들을 저장합니다.&lt;/li&gt;
&lt;li&gt;content: 컨텐츠가 저장됩니다.&lt;/li&gt;
&lt;li&gt;data: 템플랫으로 불러쓸 수 있는 데이터 파일을 저장하는 공간입니다. 데이터의 타입은 toml, yaml, 과 json이 지원됩니다.&lt;/li&gt;
&lt;li&gt;layouts: 테마를 커스터마이징할 때 기존의 테마내 탬플릿의 내용을 수정하거나 덧씌우기를 하는 템플릿을 저장하는 공간입니다.&lt;/li&gt;
&lt;li&gt;static: 이미지, 자바스크립, CSS등을 저장하는 공간&lt;/li&gt;
&lt;li&gt;themes: 사이트의 테마를 저장하는 공간.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;config.toml의 내용을 보면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl = &amp;quot;http://replace-this-with-your-hugo-site.com/&amp;quot;
languageCode = &amp;quot;en-us&amp;quot;
title = &amp;quot;My New Hugo Site&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;baseurl&lt;/code&gt;은 말 그대로 사이트내 모든 리소스의 URL의 베이스를 형성합니다. 예를 들어 &lt;code&gt;content/post/my-first-blog.md&lt;/code&gt;라는 컨텐트가 있으면 Full URL은 &lt;code&gt;http://replace-this-with-your-hugo-site.com/post/my-first-blog&lt;/code&gt;이 됩니다.&lt;/p&gt;

&lt;h1 id=&#34;첫번째-컨텐트-만들기&#34;&gt;첫번째 컨텐트 만들기&lt;/h1&gt;

&lt;p&gt;그럼, 다음 Scaffolding 명령을 써서 첫번째 블로그 포스트를 만들어 보도록 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/my-first-blog.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;content/post/my-first-blog.md&lt;/code&gt;가 만들어 지면 아래와 같이 편집을 하고 저장하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-08-24T21:51:10-04:00&amp;quot;
draft = true
title = &amp;quot;my first blog&amp;quot;

+++

# Hello, Hugo! &amp;lt;- 편집 부분
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hugo server&lt;/code&gt;명령을 써서 Hugo가 제공하는 웹서버를 구동한 다음 &lt;code&gt;http://localhost:1313&lt;/code&gt;을 브라우저로 열어 보십시요. 텅빈 페이지로 나타날 겁니다. 왜 그럴까요? 답 부터 말씀드리면 Hugo의 입장에서는 무엇으로 페이지를 렌더링할 지 아무런 정보가 없는 경우인 것입니다. &lt;code&gt;layouts&lt;/code&gt; 폴더안에 &lt;code&gt;index.html&lt;/code&gt;이라는 파일을 만들고 다음과 같이 편집해 저장하신 다음 다시 &lt;code&gt;http://localhost:1313&lt;/code&gt;을 열어 보십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;Hello, Hugo!&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Hello, Hugo!&lt;/strong&gt;라고 크게 나타나는 것을 보게 될 것입니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;http://localhost:1313/post/my-first-blog&lt;/code&gt;를 열어 보십시요. 심지어 &lt;code&gt;404 page not found&lt;/code&gt;라고 나옵니다. 텅빈 페이지가 아니고 왜 404일까요? 이유는 포스트의 Front Matter에 &lt;code&gt;draft = true&lt;/code&gt;라고 명시되어 있어서 Hugo의 입장에서는 렌더링을 할 이유가 없는 것이죠. &lt;code&gt;Ctrl-C&lt;/code&gt;로 Hugo 웹서버를 중단시킨 다음 &lt;code&gt;hugo server -D=true&lt;/code&gt;명령을 써서 다시 웹서버를 가동시키시고 &lt;code&gt;http://localhost:1313/post/my-first-blog&lt;/code&gt;를 열어 보십시요. 이번에는 404가 아니고 텅빈 페이지가 보일 겁니다. Hugo를 의인화해서 다시 설명을 드리면, &lt;code&gt;-D=true&lt;/code&gt; 플래그를 보고 드래프트 포스트도 렌더링을 해야 하는데 어떻게 해야 할 지 몰라 백지를 낸 상황인 겁니다. 이건 어떻게 고쳐야 할까요?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;layouts/post/single.html&lt;/code&gt;라는 파일을 만드시고 다음의 내용을 저장하신 다음, &lt;code&gt;http://localhost:1313/post/my-first-blog&lt;/code&gt;을 열어 보세요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Before content&amp;lt;/p&amp;gt;
{{ .Content }}
&amp;lt;p&amp;gt;After content&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫번째 포스트가 이제 보이십니까?&lt;/p&gt;

&lt;h1 id=&#34;이렇게-힘들게-만들어야-하나&#34;&gt;이렇게 힘들게 만들어야 하나?&lt;/h1&gt;

&lt;p&gt;이런 질문이 당연히 생기실 겁니다. 사이트의 구조와 컨텐츠의 템플릿을 하나씩 만들어 나가야 한다면 사이트 발생기라고 부를 이유가 없겠죠. 누군가 그런 힘든 노동을 통해 &lt;code&gt;layouts&lt;/code&gt;의 구조와 템플랫을 모두 작성했다면 공유할 수 있는 메카니즘이 필요합니다. 그런 공유의 매카니즘을 &lt;code&gt;테마(theme)&lt;/code&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;layouts/index.html&lt;/code&gt;과 &lt;code&gt;layouts/post/single.html&lt;/code&gt;을 제거하시고 테마를 사용하는 방법을 배워 봅시다. 다음과 같이 &lt;code&gt;hugo-octopress&lt;/code&gt; 테마를 설치하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm layouts/index.html
$ rm layouts/post/single.html
$ cd themes
$ git clone https://github.com/parsiya/Hugo-Octopress.git
$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테마가 설치된 후에는 Hugo의 웹서버를 다음과 같이 시작해 보십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server -D=true -t=hugo-octopress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo로 만든 당신의 첫번째 포스트가 보일 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/211484/17955233/9990f3c8-6a4e-11e6-8d3e-0c824453ba1f.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;ol&gt;
  &lt;li&gt;&lt;a id=&#34;footnote-1&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://gohugo.io/commands/&#34;&gt;Hugo의 모든 명령&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a id=&#34;footnote-2&#34;&gt;&lt;/a&gt;컨텐트 인스턴스의 메타데이터로 템플릿에서 호출해 쓸 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo 입문 - 개요</title>
      <link>https://golangkorea.github.io/post/hugo-intro/overview/</link>
      <pubDate>Tue, 23 Aug 2016 22:35:57 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/overview/</guid>
      <description>&lt;p&gt;Hugo는 현존하는 가장 빠른 정적 사이트 제너레이터(Static Site Generator)로 알려져 있습니다. 기능적인 측면에서도 여타 동적 사이트 제너레이터(Static Site Generator)에 비해 손색이 없을 뿐더러 설치가 간편하고 Go언어에 친숙한 개발자들에게는 최고의 컨텐츠 제작 환경을 제공한다고 생각합니다. &lt;a href=&#34;https://golangkorea.github.io&#34;&gt;Golang Korean Community&lt;/a&gt; 사이트도 Hugo로 제작되고 있습니다. &lt;strong&gt;Hugo 입문&lt;/strong&gt; 시리즈를 통해 이 사이트에 기여하시고자 하는 분들에게 가이드라인을 제공할 뿐만 아니라 자신만의 블로그 사이트를 쉽게 제작하고자 하는 분들에게도 도움이 되길 기원하는 마음으로 시리즈를 준비했습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/getting-started/&#34;&gt;Hugo 시작하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/content-basic/&#34;&gt;컨텐츠 제작 기초&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/theme-customizing/&#34;&gt;사이트 테마 커스터마이징 하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/taxonomy-basic/&#34;&gt;분류(Taxonomy)기능 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/how-to-contribute-content/&#34;&gt;사이트에 블로그 올리는 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>vim-go를 이용한 go 개발 환경 구축</title>
      <link>https://golangkorea.github.io/post/vim-go/</link>
      <pubDate>Mon, 22 Aug 2016 22:57:14 +0900</pubDate>
      
      <guid>https://golangkorea.github.io/post/vim-go/</guid>
      <description>

&lt;h2 id=&#34;vim&#34;&gt;Vim&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Vim&lt;/strong&gt;은 Emacs와 함께 (적어도 리눅스에서는) 가장 널리 사용하는 에디터일 것이다. 가볍고 빠르며, 어디에서나 실행되기 때문에 그 단순함에도 불구하고 여전히 사랑받고 있다. GUI 환경에서 사용하는 IDE에 익숙한 개발자라면 &amp;ldquo;요즘 같은 시대에 왠 구닥다리 터미널 기반 에디터냐&amp;rdquo;라고 생각할 지도 모르겠다. 아래 그래프를 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.redditmedia.com/Zemj1bdTRcBwW8bF_UFEVSNZ9S1VrS4tsD4HC1b9jeI.jpg?w=844&amp;amp;s=1fbbaa5fe7f8ba1ba0942191327ffd70&#34; alt=&#34;Go 에디터 사용율&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Go언어를 대상으로 조사한 결과인데, Vim이 거의 40% 정도를 차지하고 있다. Emacs까지 하면 터미널 기반 에디터를 사용하는 개발자가 절반이 넘는다. 물론 Go 언어가 시스템과 네트워크 분야의  백앤드 프로그램의 개발에 특화된 측면을 고려해야 겠지만 말이다.&lt;/p&gt;

&lt;h2 id=&#34;vim-go&#34;&gt;Vim-go&lt;/h2&gt;

&lt;p&gt;Vim은 다양한 플러그인을 제공한다. &lt;strong&gt;Vim-go&lt;/strong&gt;는 Go 개발환경을 지원하는 플러그인이다. 지원하는 기능은 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;함수, 오퍼레이터, 메서드들에 대한 Syntax highlighting&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gocode&lt;/strong&gt;를 이용한 자동완성&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:GoDef&lt;/strong&gt;를 이용해서 메서드, 변수들의 선언 위치를 네비게이션 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:GoImport&lt;/strong&gt;를 이용한 패키지 임포트&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:GoTest&lt;/strong&gt;와 &lt;strong&gt;:GoTestFunc&lt;/strong&gt;를 이용한 유닛 테스트&lt;/li&gt;
&lt;li&gt;테스트 커버리지를 위한 &lt;strong&gt;:GoCoverage&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:GoBuild&lt;/strong&gt;, &lt;strong&gt;:GoInstall&lt;/strong&gt;을 이용한 패키지 컴파일과 설치&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:GoRun&lt;/strong&gt;을 이용한 빠른 실행&lt;/li&gt;
&lt;li&gt;소스 분석을 위한 &lt;strong&gt;:GoImplements&lt;/strong&gt;, &lt;strong&gt;:GoCallee&lt;/strong&gt;, &lt;strong&gt;:GoReferrer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Lint툴 &lt;strong&gt;:GoLint&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:GoPlay&lt;/strong&gt;로 코드를 &lt;a href=&#34;https://play.golang.org&#34;&gt;play.golang.org&lt;/a&gt; 로 공유
등 개발 환경을 만들기 위한 거의 모든 기능들을 제공한다. 여기에 파일 네비게이션 플러그인, 자동완성 플러그인들을 추가로 설치하면, IDE 부럽지 않은 개발 환경을 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vim-go-설치&#34;&gt;Vim-go 설치&lt;/h2&gt;

&lt;p&gt;Vim의 플러그인들을 편리하게 관리하기 위해서 몇 가지 패키지 매니저들이 있다. 보통 Vundle 이나 &lt;strong&gt;pathogen&lt;/strong&gt;을 사용한다. 나는 pathogen을 사용하고 있다. 아래와 같이 설치하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# mkdir -p ~/.vim/autoload ~ 
/.vim/bundle
# cd ~/.vim/autoload
# curl -LSso pathogen.vim https://tpo.pe/pathogen.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.vimrc 파일을 수정한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat ~/.vimrc
execute pathogen#infect()
syntax on
filetype plugin indent on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 vim-go를 설치하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# cd ~/.vim/bundle
# git clone https://github.com/fatih/vim-go.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 개발을 위한 환경 설정은 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# export GOPATH=$HOME/golang 
# export PATH=$PATH:$GOPATH/bin
# mkdir $HOME/golang
# echo $GOPATH
/home/yundream/golang
# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/yundream/golang/bin....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vim-go 프로젝트는 구글의 mercurial에서 관리하고 있다. mercurial도 설치해야 vim-go를 빌드 할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# apt-get install mercurial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vim을 실행 한후 명령모드에서 &lt;strong&gt;:GoInstallBinaries&lt;/strong&gt;를 수행하면, 자동으로 vim-go를 빌드해서 설치해준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# vim
~
~
:GoInstallBinaries
vim-go: gocode not found. Installing github.com/nsf/gocode to folder /home/yundream/.vim-go/
vim-go: goimports not found. Installing code.google.com/p/go.tools/cmd/goimports to folder /home/yundream/.vim-go/
vim-go: godef not found. Installing code.google.com/p/rog-go/exp/cmd/godef to folder /home/yundream/.vim-go/
vim-go: oracle not found. Installing code.google.com/p/go.tools/cmd/oracle to folder /home/yundream/.vim-go/
vim-go: golint not found. Installing github.com/golang/lint/golint to folder /home/yundream/.vim-go/
vim-go: errcheck not found. Installing github.com/kisielk/errcheck to folder /home/yundream/.vim-go/
vim-go: gotags not found. Installing github.com/jstemmer/gotags to folder /home/yundream/.vim-go/
계속하려면 엔터 혹은 명령을 입력하십시오
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim-go-기능-빠르게-살펴보기&#34;&gt;Vim-go 기능 빠르게 살펴보기&lt;/h2&gt;

&lt;p&gt;Go 코드의 실행&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:GoRun
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빌드&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:make
:GoBuild
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;에러체크&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:GoErrCheck
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;패키지 임포트&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:GoImport fmt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;심볼에 대한 정의로 이동. 해동 심볼에서 :GoDef&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:GoDef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;대략 이런 식이다. 나머지 명령들은 직접 실행해 보자.&lt;/p&gt;

&lt;h2 id=&#34;자동완성&#34;&gt;자동완성&lt;/h2&gt;

&lt;p&gt;자동완성은 IDE의 가장 쓸만한 기능 중 하나일 것이다. vim의  &lt;strong&gt;YCM(YouCompleteMe)&lt;/strong&gt;를 이용해서 자동완성 기능을 추가 할 수 있다. 컴파일을 하기 때문에 python-dev와 cmake 패키지를 미리 설치해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# cd ~/.vim/bundle
# git clone https://github.com/Valloric/YouCompleteMe.git
# cd YouCompleteMe
# ./install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 자동완성 기능을 사용 할 수 있다. 아래 화면을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh5.googleusercontent.com/-n9eUbylZw50/U_C_wglq1aI/AAAAAAAAEQI/IsIWi6MYrdc/s640/golang-2.png&#34; alt=&#34;YCM 자동완성&#34; /&gt;&lt;/p&gt;

&lt;p&gt;YCM은 C, C++, Python, Java 등에도 사용 할 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;tagbar-설치&#34;&gt;TagBar 설치&lt;/h2&gt;

&lt;p&gt;ctags는 코드에 포함된 패키지, struct, 메서드의 목록을 한눈에 보여주는 애플리케이션이다. ctags를 설치하자. tagbar는 ctags를 기반으로 작동하는 플러그인이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# apt-get install ctags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tagbar 플러그인을 설치한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# cd ~/.vim/bundle
# git clone https://github.com/majutsushi/tagbar.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;strong&gt;:TagbarToggle&lt;/strong&gt; 명령으로 tagbar 네비게이션 창을 열고 닫을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh5.googleusercontent.com/-xO-ZcWBjqfQ/U_NybrcP-FI/AAAAAAAAEQ8/VjcKCUsrIE0/s640/golang-3.png&#34; alt=&#34;TagBar 적용&#34; /&gt;&lt;/p&gt;

&lt;p&gt;명령어를 입력하기 귀찮다면, 단축 키를 만들자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# cat .vimrc
......
map &amp;lt;F8&amp;gt; :TagbarToggle&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nerdtree-설치&#34;&gt;NerdTree 설치&lt;/h2&gt;

&lt;p&gt;NerdTree는 파일 네비게이션을 만들어주는 플러그인다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# cd ~/.vim/bundle
# git clone https://github.com/scrooloose/nerdtree.git 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NerdTree와 TagBar를 적용한 화면이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh6.googleusercontent.com/-yfhTJc0-xMc/U_N0PxZXmEI/AAAAAAAAERE/2n5LUOmtQGw/s640/golang-4.png&#34; alt=&#34;NerdTree와 TagBar 적용&#34; /&gt;&lt;/p&gt;

&lt;p&gt;명령을 일일이 입력하기가 귀찮아서 단축키를 등록했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# cat ~/.vimrc
set ts=4
 
map &amp;lt;F8&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt;
map &amp;lt;F2&amp;gt; :GoDef&amp;lt;CR&amp;gt;
map &amp;lt;F4&amp;gt; :TagbarToggle&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ReadMe First</title>
      <link>https://golangkorea.github.io/post/readme-first/</link>
      <pubDate>Fri, 19 Aug 2016 23:35:49 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/readme-first/</guid>
      <description>

&lt;h1 id=&#34;the-slow-hunch&#34;&gt;The Slow Hunch&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Where-Good-Ideas-Come-Innovation/dp/1594487715&#34;&gt;Where Good Ideas Come From: The Natural History of Innovation&lt;/a&gt;의 저자 Steven B. Johnson에 따르면 인류의 역사를 바꾼 혁신들은 번뜩이는 아이디어에서 시작된 경우가 매우 드물다고 합니다. 대개는 개개인의 작은 아이디어들이 오랜 시간에 걸쳐 다른 사람이 갖고 있는 비슷하거나 전혀 다른 아이디어들과 충돌하고 결합하면서 커뮤니티의 지능으로 진화하고 어느 순간 돌이킬 수 없는 변화의 모멘텀을 형성하며 세상을 바꿉니다. 커뮤니티내에 공유되고 있는 지능이 다시 역으로 개개인에게 영감과 비젼을 제시하는 상호작용을 일으키게 되는데 그런 과정은 통해 아이디어의 생산을 가능케하는 현상을 slow hunch라고 부릅니다.&lt;/p&gt;

&lt;p&gt;새로 시작하는 Golang Korean 커뮤니티 웹사이트(이하 GoSudaWeb)은 프로그래밍 언어인 Go와 퉅들, 글로벌 개발자 커뮤니티내의 트랜드와 최선의 개발방식에 대한 소개를 블로그와 뉴스레터의 형식을 통해 공유하고자 첫발을 내딛었습니다. 지속적인 지식의 축적과 폭 넗은 공유가 이루어지는 웹사이트로 성장하여 미래의 킬러앱과 킬러 아이디어를 만들어내는 slow hunch에 기여할 수 있기를 기대해 봅니다. 많은 성원 부탁드립니다.&lt;/p&gt;

&lt;h1 id=&#34;콘텐트-제작-및-웹사이트-개발-참여-신청&#34;&gt;콘텐트 제작 및 웹사이트 개발 참여 신청&lt;/h1&gt;

&lt;p&gt;GosudaWeb은 &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Page&lt;/a&gt;로 제작되고 모든 소스와 제작과정이 공개로 이루어 집니다: &lt;a href=&#34;https://github.com/golangkorea&#34;&gt;https://github.com/golangkorea&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;사이트에 포스트하기를 원하시는 분들은 &lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/how-to-contribute-content/&#34;&gt;사이트에 블로그 올리는 방법&lt;/a&gt;을 참조하시길 바랍니다.&lt;/p&gt;

&lt;p&gt;Hugo를 이용해 사이트 개발에 참여하거나 golangkorea Organization에 오픈소스 프로젝트를 시작하시고 싶으신 분들은 멤버 신청을 하실 수 있습니다. 멤버 신청은 &lt;a href=&#34;mailto:golanginkorea@gmail.com&#34;&gt;golanginkorea@gmail.com&lt;/a&gt; 이나 &lt;a href=&#34;https://gitter.im/golang-korean-community/Lobby?utm_source=share-link&amp;amp;utm_medium=link&amp;amp;utm_campaign=share-link&#34;&gt;Golang Korean Community / Lobby&lt;/a&gt;로 해 주시면 됩니다. 일단 멤버로 등록되면 &lt;a href=&#34;https://github.com/orgs/golangkorea/teams/golangkorea-website&#34;&gt;golangkorea-website team&lt;/a&gt;을 통해 개발에 참여하실 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;토론방&#34;&gt;토론방&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://golangkorea.github.io&#34;&gt;golangkorea.github.io&lt;/a&gt; 개발, 유지 보수 및 지원에 대한 토론은 &lt;a href=&#34;https://gitter.im/golang-korean-community/golangkorea.github.io?utm_source=share-link&amp;amp;utm_medium=link&amp;amp;utm_campaign=share-link&#34;&gt;Gitter Room&lt;/a&gt;을 통해 하고 있으니 많은 동참 바라겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang 프로젝트에 TDD 도입하기</title>
      <link>https://golangkorea.github.io/post/tdd-with-golang/</link>
      <pubDate>Sat, 20 Aug 2016 12:15:44 +0900</pubDate>
      
      <guid>https://golangkorea.github.io/post/tdd-with-golang/</guid>
      <description>

&lt;p&gt;여기에서 사용한 테스트 코드는 &lt;a href=&#34;https://bitbucket.org/dream_yun/handlertest&#34;&gt;Bitbucket&lt;/a&gt; 에서 다운로드 할 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;tdd&#34;&gt;TDD&lt;/h2&gt;

&lt;p&gt;클라우드와 &lt;strong&gt;MSA&lt;/strong&gt;와 &lt;strong&gt;REST&lt;/strong&gt;의 등장으로 TDD가 재조명 받고 있다. TDD를 제대로 적용하려면 상당히 많은 시간과 노력이 필요하다. 특히 여기 저기 연동되는 라이브러리나 소프트웨어가 많은 경우 테스트가 굉장히 복잡해지는데, 복잡해지는 만큼 테스트의 신뢰성도 함께 떨어진다.&lt;/p&gt;

&lt;p&gt;TDD는 &lt;strong&gt;유닛 테스트&lt;/strong&gt;를 기본으로 하는데, 애플리케이션이 복잡해지면 유닛테스트에 간섭하는 객체들이 많아진다. 이렇게 늘어난 객체들에 대해서 테스트를 진행하다 보면 테스트를 위한 설계로 변질되는 경우가 있다.&lt;/p&gt;

&lt;p&gt;데이터베이스, 소켓, UI가 서로 엉켜있는 소프트웨어를 테스트 한다고 생각해보라. 머리 좀 아플 것이다. 물론 TDD가 테스트를 쉽게 할 수 있는 설계를 지향하긴 하지만, 테스트를 쉽게 할 수 있는 설계와 테스트를 위한 설계는 엄연히 다른 것이다.&lt;/p&gt;

&lt;p&gt;TDD의 단점은 아래와 같이 정리 할 수 있다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;개발 기간이 늘어난다.&lt;/strong&gt; TDD에 익숙해졌다고 가정 할 경우 약 20% 정도 구현시간이 늘어난다. 복잡한 소프트웨어의 경우 더 구현시간은 더 늘어날 것이다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;복잡성 증가.&lt;/strong&gt; 테스트시나리오가 길어질 경우, 시나리오 자체를 관리하는 것도 작업이 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;디자인 변경.&lt;/strong&gt; 종종 TDD에 어울리지 않는 디자인의 소프트웨어를 개발 해야 하는 경우도 있다. TDD는 &lt;strong&gt;좋은 코드는 테스트하기 좋은 코드다&lt;/strong&gt;라고 주장한다. 하지만 항상 그런건 아니다. TDD에 맞추다 보니 디자인이 이상해지는 경우가 종종 생긴다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;요약하자면 실행관점에서 TDD를 위한 기본 요소는 &lt;strong&gt;유닛 테스트&lt;/strong&gt;인데, 소프트웨어가 복잡해지면 굉장히 힘들어 지는게 TDD의 문제다.&lt;/p&gt;

&lt;p&gt;달리 생각하면 소프트웨어가 단순해지면 TDD를 하기 좋은 환경이 된다는 이야기가 되겠다.&lt;strong&gt;MSA와 REST&lt;/strong&gt; 바로 그런 환경이다.&lt;/p&gt;

&lt;p&gt;MSA는 작업 서비스(애플리케이션)들을 결합해서 하나의 큰 서비스를 만드는 서비스 디자인 스타일이다. 각 MSA 서비스들은 다른 서비스들과 독립적으로 구성되고 단순한 기능을 가지도록 설계되기 때문에 유닛 테스트가 큰 효과를 발휘 할 수 있다.&lt;/p&gt;

&lt;p&gt;Go언어는 범용 시스템언어로 개발이 됐지만 &lt;strong&gt;net/http&lt;/strong&gt;와 &lt;strong&gt;gorilla&lt;/strong&gt;를 비롯해서 MSA+REST(이하 MSA) 스타일의 웹 애플리케이션을 효과적으로 만들 수 있도록 지원하고 있다. 나는 Go 언어에서 MSA 애플리케이션을 TDD로 개발하고 테스트 하는 방법을 정리 하려 한다. 이 문서에서 다룰 내용은 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Go 언어에서 제공하는 유닛테스트 프레임워크를 살펴본다.&lt;/li&gt;
&lt;li&gt;HTTP 핸들러 테스트 : HTTP 웹 서버 핸들러를 테스트하려면, 서버가 실행 중이어야 하기 때문에 메서드 단위의 유닛 테스트로는 테스트가 어렵다. &lt;strong&gt;net/http/httptest&lt;/strong&gt;패키지를 이용해서 HTTP 핸들러를 테스트할 수 있다.&lt;/li&gt;
&lt;li&gt;TDD는 유닛테스만 의미하지 않는다. 개발 에서 배포까지의 전 과정을 &lt;strong&gt;테스트&lt;/strong&gt;를 기반으로 통합하는 일련의 과정들이다. 젠킨스(Jenkins)를 이용해서 TDD를 완성해 본다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;테스트 커버리지는&lt;/strong&gt; 유닛테스트가 얼마나 잘 이루어졌는지를 측정하기 위해서 사용한다. 테스트 커버리지를 계산하고 그 결과를 문서로 출력한다. 이 문서를 젠킨스와 통합해보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;go-유닛-테스트-개요&#34;&gt;Go 유닛 테스트 개요&lt;/h2&gt;

&lt;p&gt;Go 는 테스트 프레임워크를 내장(build-in)하고 있다. &lt;strong&gt;testing&lt;/strong&gt;페키지를 이용해서 유닛 테스트 코드를 만들고 &lt;strong&gt;go test&lt;/strong&gt;명령으로 테스트를 수행하면 된다. 유닛 테스트를 위한 간단한 예제 코드를 만들었다. 코드의 이름은 math.go 다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package math

import (
    &amp;quot;errors&amp;quot;
)   

// 값들을 모두 더한다.
func Sum(nums ...int) int {
    total := 0 
    for _, num := range nums {
        total += num
    }
    return total
}   

// a를 b로 나눈다.
func Div(a float64, b float64) (float64, error) {
    if b == 0 {
        return 0.0, errors.New(&amp;quot;Can&#39;t divide by zero&amp;quot;)
    }
    return a / b, nil
}

// 문자열을 count만큼 반복하고 결과를 반화한다.
func StrRept(s string, count int) string {
    b := make([]byte, len(s)*count)
    bp := copy(b, s)
    for bp &amp;lt; len(b) {
        copy(b[bp:], b[bp:])
        bp *= 2
    }
    return string(b)
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;유닛 테스트 파일을 만든다. 파일의 이름은 &lt;strong&gt;math_test.go&lt;/strong&gt;다. 참고로 유닛 테스트 파일의 이름은 반드시 &lt;strong&gt;_test.go&lt;/strong&gt;로 끝나야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package math

import (
    &amp;quot;testing&amp;quot;
)

func Test_Sum(t *testing.T) {
    v0 := Sum(1, 2, 3)
    if v0 != 6 {
        t.Fatal(&amp;quot;1+2+3 == 6&amp;quot;)
    }

    v1 := Sum(6, 5)
    if v1 != 11 {
        t.Fatal(&amp;quot;6+5 == 11 &amp;quot;)
    }
}

func Test_Div(t *testing.T) {
    v2, _ := Div(0, 2)
    t.Log(&amp;quot;0/2 =&amp;quot;,v2)
}

func Test_StrRept(t *testing.T) {
    str := StrRept(&amp;quot;a&amp;quot;, 3)
    if len(str) != 3 {
        t.Fatal(&amp;quot;Repeat fail&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go test를 실행해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go test
PASS
ok  	_/home/yundream/workspace/golang/unitTest	0.001s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;-v&lt;/strong&gt; 옵션을 주면 자세한 테스트 정보를 확인 할 수 있다. 로그(t.Log) 정보도 함께 출력한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go test -v
=== RUN   Test_Sum
--- PASS: Test_Sum (0.00s)
=== RUN   Test_Div
--- PASS: Test_Div (0.00s)
	math_test.go:21: 0/2 = 0
=== RUN   Test_StrRept
--- PASS: Test_StrRept (0.00s)
PASS
ok  	_/home/yundream/workspace/golang/unittest	0.002s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Test_StrRept&lt;/strong&gt;테스트를 아래와 같이 수정 한 다음에 테스트해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Test_StrRept(t *testing.T) {
    str := StrRept(&amp;quot;ab&amp;quot;, 3)
    if len(str) != 3 {
        t.Fatal(&amp;quot;Repeat fail&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테스트 조건을 바꿨는데, 실수로 예상 결과를 수정하지 않았다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;# go test -v
=== RUN   Test_Sum
--- PASS: Test_Sum (0.00s)
=== RUN   Test_Div
--- PASS: Test_Div (0.00s)
	math_test.go:21: 0/2 = 0
=== RUN   Test_StrRept
--- FAIL: Test_StrRept (0.00s)
	math_test.go:27: Repeat fail
FAIL
exit status 1
FAIL	_/home/yundream/workspace/golang/unittest	0.002s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테스트 실패를 확인 할 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;testing-패키지&#34;&gt;testing 패키지&lt;/h2&gt;

&lt;p&gt;함수가 실행 된 결과가 예측한 결과와 맞아 떨어지는 지를 검사하는 방식으로 테스트를 진행 한다. &lt;strong&gt;t.Fatal()&lt;/strong&gt;, &lt;strong&gt;t.Fail()&lt;/strong&gt;등을 이용해서 테스트를 제어 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FailNow()&lt;/strong&gt;이 호출되면, 테스트 함수를 즉시 종료하고 다음 테스트 함수를 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fatal()&lt;/strong&gt;는 로그를 출력하는 걸 제외하고 &lt;strong&gt;FailNow&lt;/strong&gt; 메서드와 같은 일을 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fail()&lt;/strong&gt;이 호출되면, 테스트가 실패하더라도 함수를 종료하지 않고 다음 코드를 계속 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Error()&lt;/strong&gt;는 로그를 출력하는 걸 제외하고 &lt;strong&gt;Fail&lt;/strong&gt; 메서드와 같은 일을 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errorf()&lt;/strong&gt; 형식화된 로그를 출력한다. Fila 메서드와 같은 일을 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Log()&lt;/strong&gt; 테스트 로그를 출력한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Logf()&lt;/strong&gt; 형식화된 테스트 로그를 출력한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Failed()&lt;/strong&gt; 실패하더라도 레포트하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;assertion&#34;&gt;Assertion&lt;/h2&gt;

&lt;p&gt;테스트 코드를 만들다 보면 if 문이 코드의 절반 이상을 차지하는 걸 보게될 것이다. 비교대상도 가지각색이라서 가독성이 떨어진다. assert 함수가 필요하다. 직접 만들어 보고 싶겠지만 그냥 잘 만들어져 있는 테스트 패키지 가져다가 쓰자. 내가 요즘 쓰고 있는 테스트 패키지는 &lt;strong&gt;github.com/stretchr/testify/assert&lt;/strong&gt;이다. 패키지를 설치 한 후 아래 코드를 테스트 했다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package yours

import (
    &amp;quot;github.com/stretchr/testify/assert&amp;quot;
    &amp;quot;testing&amp;quot;
)

func TestSomething(t *testing.T) {
    // assert equality
    assert.Equal(t, 123, 125, &amp;quot;they should be equal&amp;quot;)

    // assert inequality
    assert.NotEqual(t, 123, 456, &amp;quot;they should not be equal&amp;quot;)
}
}}}
테스트를 돌려보자.
{{{#!plain
# go test
--- FAIL: TestSomething (0.00s)
        Error Trace:    yours_test.go:11
	Error:		Not equal: 123 (expected)
			        != 125 (actual)
	Messages:	they should be equal
		
FAIL
exit status 1
FAIL	_/home/yundream/workspace/golang/mytest	0.003s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테스트 코드와 테스트 결과의 가독성 모두 좋아졌다. 이 패키지는 &lt;strong&gt;assert&lt;/strong&gt;외에도 &lt;strong&gt;mock&lt;/strong&gt;, &lt;strong&gt;http 테스트&lt;/strong&gt;, &lt;strong&gt;suite&lt;/strong&gt;등 테스트를 위한 다양한 툴들을 지원한다.&lt;/p&gt;

&lt;h2 id=&#34;http-핸들러-테스트&#34;&gt;HTTP 핸들러 테스트&lt;/h2&gt;

&lt;p&gt;HTTP 핸들러의 경우 웹 서버를 띄워야 하기 때문에, 메서드보다 테스트가 까다롭다. 아래의 방식으로 테스트 할 수 있다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;net/http/httptest&lt;/strong&gt; 패키지를 이용한 테스트. httptest를 이용하면 루프백(127.0.0.1)에 바인드 되는 서버를 띄울 수 있다. 이후 net/http에서 제공하는 클라이언트 메서드들을 이용하면 &lt;strong&gt;서버 &amp;amp; 클라이언트&lt;/strong&gt;모드에서 테스트 할 수 있다.&lt;/li&gt;
&lt;li&gt;아예 빌드하고 실행하고, HTTP 클라이언트를 이용해서 테스트 한다.
각각의 장/단점이 있다. 1의 경우 테스트 커버리지를 확인 할 수 있고, 2의 경우에는 통합된 환경에서의 테스트가 가능하다. 나는 1과 2의 방법을 모두 다 사용하고 있다. 여기에서는 &lt;strong&gt;httptest&lt;/strong&gt;를 이용한 테스트를 살펴볼 생각이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;테스트에 사용한 소스코드 트리다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;.
├── handler
│   ├── handler.go
│   └── handler_test.go
└── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;net/http, gorilla, 패키지를 이용해서 개발 했다. GET /ping에 대해서 &amp;ldquo;pong&amp;rdquo;를 리턴하는 일을 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package handler

import (
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;github.com/gorilla/mux&amp;quot;
    &amp;quot;net/http&amp;quot;
)

type Handler struct {
    router *mux.Router
}

func (h Handler) Init() {
    h.router = mux.NewRouter()
    h.router.HandleFunc(&amp;quot;/ping&amp;quot;, h.Ping).Methods(&amp;quot;GET&amp;quot;)
    http.Handle(&amp;quot;/&amp;quot;, h.router)
}
func (h Handler) Ping(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, &amp;quot;pong&amp;quot;)
}
func (h Handler) Calc(w http.ResponseWriter, r *http.Request) {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테스트 코드다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// handler_test.go
package handler

import (
    &amp;quot;github.com/gorilla/handlers&amp;quot;
    &amp;quot;github.com/stretchr/testify/assert&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/http/httptest&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;testing&amp;quot;
)

var (
    server  *httptest.Server
    testUrl string
)

type Response struct {
    Content string
    Code    int
}

func Test_Init(t *testing.T) {
    logfile, err := os.OpenFile(&amp;quot;/tmp/test.log&amp;quot;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0755)
    assert.Nil(t, err, &amp;quot;&amp;quot;)
    h := Handler{}
    h.Init()
    server = httptest.NewServer(handlers.CombinedLoggingHandler(logfile, http.DefaultServeMux))
    testUrl = server.URL
}

func Test_Ping(t *testing.T) {
    res, err := DoGet(testUrl + &amp;quot;/ping&amp;quot;)
    assert.Nil(t, err, &amp;quot;&amp;quot;)
    assert.Equal(t, 200, res.Code, &amp;quot;PING API&amp;quot;)
    assert.Equal(t, &amp;quot;pong&amp;quot;, res.Content, &amp;quot;PONG Message&amp;quot;)
}

func DoGet(url string) (*Response, error) {
    response, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer response.Body.Close()
    contents, err := ioutil.ReadAll(response.Body)
    if err != nil {
        return nil, err
    }
    return &amp;amp;Response{Content: string(contents), Code: response.StatusCode}, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;httptest&lt;/strong&gt;패키지는 테스트를 위해서 내장된 웹 서버를 실행한다. 따라서 핸들러 등록, 데이터베이스 연결과 같이 서비스를 위해서 필요한 자원들을 초기화 해야 한다. &lt;strong&gt;Test_init&lt;/strong&gt;메서드를 이용해서 서비스를 초기화 하고 있다. 테스트 코드에 대한 디버깅은 &lt;strong&gt;testing.T.Log&lt;/strong&gt; 계열의 메서드를 이용해서 모니터에 표준출력하는 방식으로 진행하는데, 웹 서버가 실행되는 방식이라서 로그를 표준출력 할 수 없다. 그래서 /tmp/test.log에 access log를 남기기로 했다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;httptest.NewServer&lt;/strong&gt; 메서드를 실행하면, 웹 서버가 실행된다. 웹 서버의 접근 URL은 server.URL에 저장돼 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Test_Ping&lt;/strong&gt;에서 ping API를 테스트한다. 테스트는 http client를 이용한다. 200 OK와 &amp;ldquo;pong&amp;rdquo; 메시지를 검사하고 있다. 테스트결과다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;# go test -v
=== RUN   Test_Init
--- PASS: Test_Init (0.00s)
=== RUN   Test_Ping
--- PASS: Test_Ping (0.00s)
PASS
ok  	bitbucket.org/dream_yun/handlertest/handler	0.003s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;존재하지 않는 페이지를 요청 할 경우 &lt;strong&gt;404 Page Not Found&lt;/strong&gt;를 반환해야 할테다. 이를 테스트하기 위한 코드를 만들었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Test_APINotFound(t *testing.T) {
    res, err := DoGet(testUrl + &amp;quot;/myfunc&amp;quot;)
    assert.Nil(t, err, &amp;quot;&amp;quot;)
    assert.Equal(t, 404, res.Code, &amp;quot;Unknown API&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 테스트 시나리오에 따라서 테스트 코드를 추가하면 된다.&lt;/p&gt;

&lt;h2 id=&#34;서비스간-연동-테스트&#34;&gt;서비스간 연동 테스트&lt;/h2&gt;

&lt;p&gt;MSA 모델을 따르는 애플리케이션을 만들다 보면, 다른 (REST)애플리케이션과 통신 해야 할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://docs.google.com/drawings/d/1VaRfN4dntpTqQb_zOZhXMXDxVa49PzXfIOR9KyPO_Co/pub?w=521&amp;amp;h=255&#34; alt=&#34;MSA에서의 REST API를 이용한 서비스 이용&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App02&lt;/strong&gt;는 서비스에서 발생한 다양한 데이터들을 관리하는 일을 한다. 유저가 업로드한 이미지, 문서 파일은 App-02로 전달된다. App-02는 이 파일들을 유저 설정에 따라서 S3, DropBox, Google Drive 등으로 전송한다.&lt;/p&gt;

&lt;p&gt;나는 App01 서비스도 유저가 입력한 연산과 그 결과를 &lt;strong&gt;App02&lt;/strong&gt;를 이용해서 저장하기로 했다. &amp;ndash; 이게 어떤 쓸모가 있는 기능인지는 묻지도 말고 따지지도 말자 &amp;ndash; &lt;strong&gt;코드의 추가와 추가된 코드에 대한 테스트&lt;/strong&gt;가 필요하다.&lt;/p&gt;

&lt;p&gt;App02를 직접 띄운다음 테스트 하는 방법도 있다. 이 방법에 따라 테스트 하려면 App02를 단순 실행하는 것이 아닌, App02가 제대로 실행 할 수 있는 환경을 만들어야 한다. 그러니까 S3, DropBox, Google Drive 등과 연동할 수 있는 환경을 &lt;strong&gt;개발 서버에 만들어야&lt;/strong&gt; 한다. 애로 사항이 꽃필 것이다. 최종 연동 테스트에서는 이렇게 해야겠지만, 개발단계에서 이렇게 하기는 쉽지 않다.&lt;/p&gt;

&lt;p&gt;나는 입력과 출력만 검사하는 &lt;strong&gt;블랙 박스 테스트&lt;/strong&gt;를 실행하기로 했다. httptest 패키지를 이용해서 &lt;strong&gt;App02 테스트 서버&lt;/strong&gt;를 만들었다. 물론 App02 테스트 서버를 만들기 위해서는 App02의 API 명세서와 App02 패키지가 필요하다. 아래는 테스트 서버 코드다. handler 디렉토리 밑에 만들었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//  handler/app02_test_server.go
package handler

import (
    &amp;quot;bitbucket.org/dream_yun/app02&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;github.com/gorilla/handlers&amp;quot;
    &amp;quot;github.com/gorilla/mux&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/http/httptest&amp;quot;
    &amp;quot;os&amp;quot;
)

type TestApiServer struct {
    router *mux.Router
}

// 실행 후 테스트 서버의 URL을 반환한다.
func (api *TestApiServer) Run() string {

    api.router = mux.NewRouter()
    api.router.HandleFunc(&amp;quot;/save/{serviceName}&amp;quot;, api.Save).Methods(&amp;quot;POST&amp;quot;)
    api.router.HandleFunc(&amp;quot;/save/{serviceName}/{fileName}&amp;quot;, api.ReadFile).Methods(&amp;quot;GET&amp;quot;)

    logfile, _ := os.OpenFile(&amp;quot;/tmp/app02_test.log&amp;quot;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)
    server := httptest.NewServer(handlers.CombinedLoggingHandler(logfile, api.router))
    return server.URL
}

// Save API다. 여기에 여러가지 테스트 조건들을 코딩하면 된다. 
func (api TestApiServer) Save(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    serviceName := vars[&amp;quot;serviceName&amp;quot;]
    if serviceName != &amp;quot;calc&amp;quot; {
        w.WriteHeader(http.StatusBadRequest)
        return
    }
    fmt.Fprintf(w, app02.ServiceOK)
}

// 저장된 파일을 가져온다.
func (api TestApiServer) ReadFile(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    serviceName := vars[&amp;quot;serviceName&amp;quot;]
    fileName := vars[&amp;quot;fileName&amp;quot;]
    if serviceName != &amp;quot;calc&amp;quot; {
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    if fileName == &amp;quot;my.jpg&amp;quot; {
        fmt.Fprintf(w, app02.ServiceOK)
        return
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;연산을 끝낸 후에 Save API를 호출하도록 Div 메서드를 수정했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Handler struct {
    router     *mux.Router
    fileServer string
}

func (h Handler) Init(fileServer string) {
    h.router = mux.NewRouter()
    h.fileServer = fileServer
    h.router.HandleFunc(&amp;quot;/ping&amp;quot;, h.Ping).Methods(&amp;quot;GET&amp;quot;)
    h.router.HandleFunc(&amp;quot;/div/{a}/{b}&amp;quot;, h.Div).Methods(&amp;quot;GET&amp;quot;)
    http.Handle(&amp;quot;/&amp;quot;, h.router)
}

func (h Handler) Div(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    a := vars[&amp;quot;a&amp;quot;]
    b := vars[&amp;quot;b&amp;quot;]

    ai, err := strconv.Atoi(a)
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    bi, err := strconv.Atoi(b)
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }

    if bi == 0 {
        w.WriteHeader(http.StatusNotAcceptable)
        return
    }
    if ai == 0 { 
        w.WriteHeader(http.StatusNotAcceptable)
        return
    }
    
    DoPost(h.fileServer+&amp;quot;/save/calc&amp;quot;, &amp;quot;a/b&amp;quot;)
    fmt.Fprintf(w, &amp;quot;%d&amp;quot;, ai/bi)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Handler 구조체에 fileServer 변수를 추가했다. 여기에는 app02 서버의 주소가 저장된다.&lt;/li&gt;
&lt;li&gt;매개변수로 app02 서버를 받도록 Handler.Init() 메서드를 수정했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Test 코드도 수정했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Test_Init(t *testing.T) {
    logfile, err := os.OpenFile(&amp;quot;/tmp/test.log&amp;quot;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0755)
    assert.Nil(t, err, &amp;quot;&amp;quot;)

    FileServer := TestApiServer{}
    fileServerAddr := FileServer.Run()
    h := Handler{}
    h.Init(fileServerAddr)
    server = httptest.NewServer(handlers.CombinedLoggingHandler(logfile, http.DefaultServeMux))
    testUrl = server.URL
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TestApiServer의 바인드 주소를 읽어서 Handler.Init() 메서드에 넘기도록 테스트 코드를 수정했다. 이제 테스트를 실행하면 TestAPIServer가 실행되고, Div 메서드가 TestAPIServer의 save api를 호출하는 것을 볼 수 있을 거다.&lt;/p&gt;

&lt;p&gt;이 테스트는 완전하지 않다. Div의 DoPost 호출 부분을 충분히 테스트하지 않았기 때문이다. 테스트 커버리지를 높이려면, DoPost를 호출하는 별도의 메서드를 만들어서 메서드의 입/출력을 테스트 할 수 있도록 해야 한다.&lt;/p&gt;

&lt;p&gt;여기에서 중요한 점은 &lt;strong&gt;테스트를 쉽게 하기 위해서 메서드들을 수정&lt;/strong&gt;했다는 점이다. TDD에서는 코드에 맞는 테스트를 하는게 아니고, 테스트에 맞는 코드를 만든다.&lt;/p&gt;

&lt;h2 id=&#34;목업-vs-직접-구성&#34;&gt;목업 vs 직접 구성&lt;/h2&gt;

&lt;p&gt;예제로 삼았던 ping API 서버는 외부 소프트웨어의 도움 없이 작동한다. 하지만 현실에서 이런 코드를 찾기는 어렵다. 마이에스큐엘(Mysql), 몽고디비(Mongodb), 주키퍼(zookeeper), 레디스(Redis) 등 수많은 다른 애플리케이션들과 통신을 한다. 어떻게 테스트 해야 할까.&lt;/p&gt;

&lt;p&gt;연동 애플리케이션과 서버를 모두 구축해서 테스트 하는 방법이 있다. 마이에스큐엘, 몽고디비, 레디스.. 등등을 모두 설치해서 테스트 하는 거다. 이 방법의 단점은 상당히 귀찮다는 것이다. 혼자 하는 개발하는 하고 있다면 좀 귀찮아도 해볼만 하지만, 여럿이 개발한다면 애로사항이 꽃필 것이다. 이외에도 데이터베이스 오류 상황에서, 소프트웨어가 어떻게 작동할지를 테스트하기가 쉽지 않다는 것도 문제다.&lt;/p&gt;

&lt;p&gt;이 문제는 &lt;strong&gt;mocks/stubs&lt;/strong&gt;으로 모의 객체를 만들어서 테스트하는 것으로 테스트 커버리지는 늘리면서도 테스트 시간을 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;결론부터 말하자면 난 목업을 이용하지 않고 있다. 작동하는 소프트웨어들과 직접 연동해서 테스트 한다. 개발/테스트 환경 구축의 번거로움은.. 글쎄 나는 (데이터베이스를 설치하고 설정하는) 정도의 번거로움은 감수해야 하고, 감수한 만큼 개발자에게 이득이 있다고 생각하는 입장이다. 그리고 세상이 좋아졌다. VM, Container, Vagrant 등을 이용하면 개발환경을 손쉽게 구성하고 배포, 공유 할 수 있다.&lt;/p&gt;

&lt;h2 id=&#34;테스트-커버리지&#34;&gt;테스트 커버리지&lt;/h2&gt;

&lt;p&gt;테스트에 대한 품질은 테스트 커버리지로 측정 할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go test -cover
PASS
coverage: 100.0% of statements
ok  	bitbucket.org/dream_yun/handlertest/handler	0.004s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모든 코드를 완전히 테스트 하고 있다. 이 예제로는 테스트 커버리지를 확인하기가 애매모호해서, API를 추가했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// package handler
func (h Handler) Div(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(request)
    a := vars[&amp;quot;a&amp;quot;]
    b := vars[&amp;quot;b&amp;quot;]

    if b == 0 {
        w.WriteHeader(http.StatusNotAcceptable)
        return
    }
    if a == 0 {
        w.WriteHeader(http.StatusNotAcceptable)
        return
    }
    ia, err := strconv.Atoi(a)
    ib, err := strconv.Atoi(b)
    fmt.Fprint(w)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금은 코드를 먼저 만들었지만 TDD의 원칙을 정확히 따르려면, 테스트 코드를 먼저 만들고 나서 코드를 만들어야 할 것이다. 다만 MSA의 경우에는 API단위로 하는 일이 특정되기 때문에, 코드를 먼저 만들고 테스트 코드를 만드는 것도 괜찮은 방법이라고 생각한다. &lt;strong&gt;TDD를 위한 TDD&lt;/strong&gt;가 문제다라는 주장이 나오는 이유를 생각해보자. 완전한 방법, 완전한 툴은 없다. 자신의 역량과 환경에 적절하게 응용해서 사용해야 한다.&lt;/p&gt;

&lt;p&gt;유닛 테스트를 돌려보자. 테스트 커버리지가 떨어진 걸 확인 할 수 있을 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go test -cover
PASS
coverage: 21.7% of statements
ok  	bitbucket.org/dream_yun/handlertest/handler	0.004s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Div 메서드에 대한 테스트 코드를 만들어서 커버리지를 올리기로 했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Test_Div(t *testing.T) {
    res, err := DoGet(testUrl + &amp;quot;/div/4/2&amp;quot;)
    assert.Nil(t, err, &amp;quot;&amp;quot;)
    assert.Equal(t, http.StatusOK, res.Code)
    assert.Equal(t, &amp;quot;2&amp;quot;, res.Content)
    
    res, err = DoGet(testUrl + &amp;quot;/div/4/a&amp;quot;)
    assert.Nil(t, err, &amp;quot;&amp;quot;)
    assert.Equal(t, http.StatusInternalServerError, res.Code, &amp;quot;Invalide argument&amp;quot;)
    
    res, err = DoGet(testUrl + &amp;quot;/div/0/4&amp;quot;)
    assert.Nil(t, err, &amp;quot;&amp;quot;)
    assert.Equal(t, http.StatusNotAcceptable, res.Code, &amp;quot;Invalide argument&amp;quot;)
    
    res, err = DoGet(testUrl + &amp;quot;/div/4/0&amp;quot;)
    assert.Nil(t, err, &amp;quot;&amp;quot;)
    assert.Equal(t, http.StatusNotAcceptable, res.Code, &amp;quot;Invalide argument&amp;quot;)
}   
```go
```sh
# go test -cover
PASS
coverage: 91.3% of statements
ok  	bitbucket.org/dream_yun/handlertest/handler	0.005s
}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테스트 커버리지는 &amp;ldquo;이 소프트웨어는 적어도 이 정도의 코드 영역에 대해서 테스트 하고 있다&amp;rdquo;는 것을 알려준다. 특히 코드에 대한 리펙토링이나 기능 추가시 필요한 품질을 측정하는데 매우 좋은 자료가 된다. 예를 들어 현재 릴리즈된 소프트웨어의 커버리지가 90%일 경우, 수정된 코드의 커버리지를 90%로 맞춘다면 적어도 이전에 테스트했던 내용들은 모두 테스트 했으며, 이전 수준에서의 품질을 유지 하고 있다고 예상 할 수 있을 것 이다.&lt;/p&gt;

&lt;p&gt;스타트업의 경우 서비스의 품질보다 출시 시기가 중요한 경우가 많다. 이 경우 소위 &lt;strong&gt;기술부채&lt;/strong&gt;라는 명목으로 품질을 희생하는 경우가 많은데,  나중에 기술부채를 제거하기 위해서 엄청난 시간과 노력을 투입해야 할 수 있다. 개발 환경을 갖추지 못한 상태에서 급하게 기술부채를 제거 할 경우 곤욕을 치를 수 있고, 서비스의 발목을 잡을 수도 있다.&lt;/p&gt;

&lt;p&gt;테스트 코드는 리펙토링과 설계변경을 쉽게 할 수 있도록 도와준다. 테스트 커버리지를 관리하는 것으로 일관성 있는 품질을 달성 할 수 있다. 유닛 테스트를 이용해서 기술 부채를 관리 할 수 있다.&lt;/p&gt;

&lt;p&gt;테스트 커버리지의 목표를 90%로 잡았다고 가정해 보자. 91.3 % 이니 이 정도면 충분하다고 생각 할 수 있겠으나 그렇지 않다. &lt;strong&gt;서비스의 보안수준은 가장 약한 보안 고리에 의해서 결정된다.&lt;/strong&gt; 서비스 품질 역시 마찬가지로 가장 약한 고리가 서비스의 전체 품질을 결정 한다. 따라서 테스트 하지 않은 부분이 서비스에 중요한 영향을 미칠 수 있는 지 점검 해야 한다. 위의 정보로는 어느 부분이 테스트가 안됐는지를 확인 할 수 없다.&lt;/p&gt;

&lt;p&gt;테스트 커버리지 레포트를 만들어 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;# go test -coverprofile=coverage.out 
# go tool cover -html=coverage.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;-coverprofile&lt;/strong&gt; 옵션을 이용하면 테스트한 코드 영역에 대한 레포트가 만들어진다. 일반 텍스트 파일인데, &lt;strong&gt;tool cover&lt;/strong&gt; 명령을 이용해서 html 파일로 변환 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ryudmq.by3302.livefilestore.com/y3mJYLhYTZWyMa4UE1wfN3H-D-RKFA6M7rnil_bUWKMDXdP86xNzJ77MkFXFGN32oS68Pjw5yDOVed1st1toTzjOtip0WaCuWJhEhT5pN8B7b3s3YVrUT9T2ixkHFWHBpM8IgHKykDGGRg5bo_7KA5p-8Ju9AGn4AX4vE0T8xv3vME?width=660&amp;amp;height=432&amp;amp;cropmode=none&#34; alt=&#34;go cover html 화면&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;strconv.Atoi()&lt;/strong&gt; 메서드에 대한 테스트가 빠져있음을 알 수 있다. 이에 대해서  &amp;ldquo;Div API는 클라이언트가 숫자(0-9)가 아닌 다른 값을 보낼 수도 있으므로, 에러 체크가 필요하다. 그리고 변수 a, b에 대한 타당성(숫자인지, int64 범위의 값인지 등)을 검사하는 코드도 추가해야 한다&amp;rdquo;라는 평가를 할 수 있을 것이다.&lt;/p&gt;

&lt;h2 id=&#34;gocov&#34;&gt;gocov&lt;/h2&gt;

&lt;p&gt;go에서 제공하는 기본 툴도 쓸만하긴 하지만, 레포팅 기능이 썩 맘에 들지 않는다. 그래서 &lt;strong&gt;gocov&lt;/strong&gt;라는 툴을 이용해서 레포트를 만들기로 했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go get github.com/axw/gocov/gocov
# go get github.com/matm/gocov-html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;gocov test&lt;/strong&gt;를 이용해서 커버리지 데이터파일을 만든다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# gocov test ./ &amp;gt; handler.json
ok  	bitbucket.org/dream_yun/handlertest/handler	0.005s	coverage: 91.3% of statements
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handler.json을 html 파일로 변환한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# gocov-html handler.json &amp;gt; handler.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;브라우저로 읽어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ryscvq.by3302.livefilestore.com/y3miXS8j97x5BezCReIZYH2BNOnlXESm33jhcUAzj_wBD2JzF_k12xyAOv0aKwUj1EhFHkdVZ4bDYFR9Jgvk3TxacSU-W-TU0Xg2MUm1C_i4F-rtt0OqVQr2aDwtRToqAXndvtyN8u6aQHEN8DWVFneg32NSTz71iH8RhcDyMmmqZU?width=660&amp;amp;height=477&amp;amp;cropmode=none&#34; alt=&#34;gocov 이미지 1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://rytnsa.by3302.livefilestore.com/y3mdq3P4WAWJGSzJnwg1NuQ0Ck4zue-ttulK2zZ2fPppUVuAe-AMqOLrWK4YVUXoFbQ_rQxH3kL1LEJgSFH8MZP68u57aqPCnxJ3AY9AATwCjtCHHBDc_fV3n6BgAZy_SdNCC57KNiavbNIMchRgDbi0_CbpZYrCMso5989qPFUJSU?width=660&amp;amp;height=477&amp;amp;cropmode=none&#34; alt=&#34;gocov 이미지 2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;훨씬 보기 좋아졌다.&lt;/p&gt;

&lt;h2 id=&#34;젠킨스와의-통합&#34;&gt;젠킨스와의 통합&lt;/h2&gt;

&lt;p&gt;이미 젠킨스를 통해서 테스트를 자동화 하고 있다. 여기에 레포트만 추가하면 된다.&lt;/p&gt;

&lt;p&gt;젠킨스에 웹 서버를 설치하고 gocov test, gocov-html 과정에서 나온 html 결과물을 웹 서버 디렉토리에 저장해서 레포팅 하는 방법도 있다. 하지만 레포팅 결과물이 젠킨스 대시보드와 분리된다는 점이 썩 맘에 들지 않는다. 그리고 gocov-html은 &lt;strong&gt;현재 상태&lt;/strong&gt;만 보여준다는 문제가 있다. 테스트 결과를 평가 하기 위해서는 이전 테스트 결과도 함께 볼 수 있어야 한다. 그래서 젠킨스의 코드 테스트 커버리지 레포팅 플러그인인 &lt;a href=&#34;http://cobertura.github.io/cobertura&#34;&gt;Cobertura&lt;/a&gt;를 사용하기로 했다. Cobertura는 자바코드의 커버리지를 측정하기 위해서 만들어진 툴이지만 XML 포멧만 맞춘다면 다른 언어에도 문제없이 사용 할 수 있다.&lt;/p&gt;

&lt;p&gt;gocov의 결과를 xml로 출력하기 위해서 gocov-xml을 설치했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# go get github.com/AlekSi/gocov-xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래와 같이 테스트커버리지 결과를 xml 문서로 출력할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# gocov test ./ | gocov-xml &amp;gt; coverage.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;젠킨스에 cobertura 플러그인을 설치하는 과정은 &lt;a href=&#34;http://www.joinc.co.kr/w/man/12/jenkins&#34;&gt;Go언어와 Jenkins&lt;/a&gt;문서를 참고하자. 아래는 적용 결과다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://marcelog.github.io/articles/cobertura_example_covertool.png&#34; alt=&#34;coberatura 레포팅&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;tdd-통합-프로세스&#34;&gt;TDD 통합 프로세스&lt;/h2&gt;

&lt;p&gt;MSA 모델을 따르는 소프트웨어의 개발에서 배포 단계까지의 테스트 방식을 정리해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://docs.google.com/drawings/d/18iqVYcMa8_en8Ro2OjwhnTIujD7cdPCPwxtoNNtNHy0/pub?w=882&amp;amp;h=469&#34; alt=&#34;TDD 통합 프로세스&#34; /&gt;&lt;/p&gt;

&lt;p&gt;개발 단계에서는 &lt;strong&gt;화이트 박스 테스트&lt;/strong&gt;와 &lt;strong&gt;블랙 박스 테스트&lt;/strong&gt;를 함께 사용한다. 직접 제어하고 테스트 할 수 있는 코드들은 화이트 박스 테스트의 대상이다. 애플리케이션을 구성하고 있는 핸들러와 핸들러에서 호출하는 메서드들이다.&lt;/p&gt;

&lt;p&gt;다른 애플리케이션과 (REST API로) 연결된 코드의 경우에는 블랙 박스 테스트를 진행한다. 해당 애플리케이션 개발자로 부터 API 규격을 받아서, 입력과 출력을 테스트 하는 방식이다. &lt;strong&gt;httptesting&lt;/strong&gt;을 이용해서 블랙 박스 테스트를 위한 웹 서버를 띄우면 된다. 입력과 출력의 사양은 연동 애플리케이션의 패키지를 그대로 사용할테니, 문서의 내용과 코드가 맞지 않는다고 해도 문제될게 없다. 그냥 패키지를 참고해서 개발해도 된다. 연동 애플리케이션의 규격이 변경될 경우 테스트에러가 떨어질테니 개발단계에서 문제를 해결 할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;통합 단계에서는 연동 테스트까지 진행한다. 최신 버전의 애플리케이션을 실행 하고, 직접 API를 전송해서 테스트 하는 방식이다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>